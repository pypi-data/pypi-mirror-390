"""Core message sending functionality for ACP."""

import logging
import uuid
from typing import Any, Dict, Optional, Union, Callable, List

import anyio
from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream

from ..jsonrpc import (
    JSONRPCRequest,
    JSONRPCNotification,
    JSONRPCResponse,
    JSONRPCError,
    create_request,
    create_notification,
)


###############################################################################
# Cancellation Support
###############################################################################


class CancellationToken:
    """Token to enable request cancellation."""

    def __init__(self) -> None:
        self._cancelled = False
        self._callbacks: List[Callable[[], None]] = []

    def cancel(self) -> None:
        """Mark this token as cancelled."""
        self._cancelled = True
        for callback in self._callbacks:
            try:
                callback()
            except Exception as e:
                logging.error(f"Error in cancellation callback: {e}")

    @property
    def is_cancelled(self) -> bool:
        """Check if cancellation was requested."""
        return self._cancelled

    def add_callback(self, callback: Callable[[], None]) -> None:
        """Add a callback to be called on cancellation."""
        self._callbacks.append(callback)
        if self._cancelled:
            callback()


class CancelledError(Exception):
    """Raised when a request is cancelled via CancellationToken."""

    pass


###############################################################################
# Public API - JSON-RPC send/receive
###############################################################################


async def send_message(
    read_stream: MemoryObjectReceiveStream[
        Union[JSONRPCResponse, JSONRPCError, JSONRPCNotification]
    ],
    write_stream: MemoryObjectSendStream[Union[JSONRPCRequest, JSONRPCNotification]],
    method: str,
    params: Optional[Dict[str, Any]] = None,
    *,
    timeout: float = 60.0,
    message_id: Optional[str] = None,
    cancellation_token: Optional[CancellationToken] = None,
) -> Union[Dict[str, Any], Any]:
    """Send a JSON-RPC 2.0 request message and await the matching response.

    Args:
        read_stream: Stream to receive JSON-RPC messages.
        write_stream: Stream to send JSON-RPC messages.
        method: The JSON-RPC method name.
        params: Parameters dict for the call.
        timeout: Timeout in seconds for the response (default 60s).
        message_id: Custom request ID; autogenerated if None.
        cancellation_token: Token to enable request cancellation.

    Returns:
        The 'result' field of the JSON-RPC response.

    Raises:
        TimeoutError: If no matching response arrives in time.
        Exception: For JSON-RPC errors (raises exception with error details).
        CancelledError: If the request was cancelled via the token.
    """
    if message_id is None:
        message_id = str(uuid.uuid4())

    # Create and send request
    request = create_request(method=method, params=params, id=message_id)

    try:
        await write_stream.send(request)
    except Exception as e:
        logging.error(f"Failed to send request: {e}")
        raise

    # Wait for response with timeout and cancellation support
    try:
        with anyio.fail_after(timeout):
            while True:
                # Check for cancellation
                if cancellation_token and cancellation_token.is_cancelled:
                    raise CancelledError(f"Request {message_id} was cancelled")

                message = await read_stream.receive()

                # Handle notification (not a response)
                if isinstance(message, JSONRPCNotification):
                    # Notifications should be handled by a separate listener
                    # For now, just log and continue waiting
                    logging.debug(f"Received notification: {message.method}")
                    continue

                # Check if this is our response
                if isinstance(message, (JSONRPCResponse, JSONRPCError)):
                    if message.id == message_id:
                        # This is our response
                        if isinstance(message, JSONRPCResponse):
                            return message.result
                        else:
                            # Error response
                            error = message.error
                            error_msg = error.get("message", "Unknown error")
                            error_code = error.get("code", -1)
                            error_data = error.get("data")
                            raise Exception(
                                f"JSON-RPC error {error_code}: {error_msg}"
                                + (f" - {error_data}" if error_data else "")
                            )
                    else:
                        # Not our response, continue waiting
                        logging.debug(f"Received response for different request: {message.id}")
                        continue

    except TimeoutError:
        logging.error(f"Timeout waiting for response to {method}")
        raise TimeoutError(f"Timeout waiting for response to {method} (request {message_id})")


async def send_notification(
    write_stream: MemoryObjectSendStream[Union[JSONRPCRequest, JSONRPCNotification]],
    method: str,
    params: Optional[Dict[str, Any]] = None,
) -> None:
    """Send a JSON-RPC 2.0 notification (no response expected).

    Args:
        write_stream: Stream to send JSON-RPC messages.
        method: The JSON-RPC method name.
        params: Parameters dict for the notification.

    Raises:
        Exception: If sending fails.
    """
    notification = create_notification(method=method, params=params)

    try:
        await write_stream.send(notification)
    except Exception as e:
        logging.error(f"Failed to send notification: {e}")
        raise
