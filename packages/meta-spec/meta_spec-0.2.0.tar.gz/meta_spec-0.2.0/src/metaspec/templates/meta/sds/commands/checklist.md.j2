---
description: Generate quality checklist for protocol specification - validates protocol quality, NOT implementation correctness
---

## Checklist Purpose: "Unit Tests for Protocol Specifications"

**CRITICAL CONCEPT**: Checklists are **UNIT TESTS FOR SPECIFICATION WRITING** - they validate the quality, clarity, and completeness of protocol specifications.

**NOT for implementation verification**:
- âŒ "Verify parser handles protocol correctly"
- âŒ "Test validator catches protocol violations"
- âŒ "Confirm toolkit implements protocol"

**FOR protocol specification quality validation**:
- âœ… "Are all protocol entities clearly defined? [Completeness]"
- âœ… "Are operation schemas consistently specified? [Consistency]"
- âœ… "Are error codes documented with examples? [Completeness]"
- âœ… "Can 'must be valid' be objectively measured? [Clarity]"

---

## âš ï¸ CRITICAL: This Command Does NOT Modify spec.md

**Checklist is a VALIDATION tool, NOT a modification tool.**

**What this command does**:
- âœ… Read `specs/protocol/XXX-name/spec.md`
- âœ… Generate/update `checklists/comprehensive-quality.md`
- âœ… Identify issues (âœ… Pass / âš ï¸ Partial / âŒ Missing)
- âœ… Track improvement across iterations

**What this command does NOT do**:
- âŒ Modify `spec.md`
- âŒ Fix issues automatically
- âŒ Add missing fields or descriptions

**When issues are found, user should**:
- **Draft toolkit** (v0.x.x): Direct edit `spec.md` â†’ Re-run checklist (update mode)
- **Released toolkit** (v1.x.x): Use `/metaspec.proposal` â†’ `/metaspec.apply`

See `docs/evolution-guide.md` for decision guide.

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

## Execution Flow

### 1. Check for existing checklist

**CRITICAL**: Before generating, check if checklist already exists:

```bash
ls specs/protocol/XXX-name/checklists/
```

**If checklist exists**, ask user:

| Mode | Action | When to Use |
|------|--------|-------------|
| **update** | Update scores/status, add iteration section | Protocol improved, want to track progress |
| **new** | Create new checklist (backup existing) | Complete restart, different focus |
| **append** | Add new checklist for different focus | Existing checklist still valid, new aspect |

**Default**: If user says "re-run", "verify improvement" â†’ choose **update** mode

**If NO checklist exists** â†’ proceed to step 2

---

### 2. Clarify intent

Generate up to 3 contextual clarifying questions based on user input:

**Example questions**:
- "Should this checklist focus on entity definitions, operations, or both?"
- "Is this for protocol review (pre-toolkit) or protocol validation (post-toolkit)?"
- "Should we include constitution alignment checks?"

**Present options as table**:
| Option | Focus | Why It Matters |
|--------|-------|----------------|
| A | Entity Definitions | Validates entity schemas, fields, constraints |
| B | Operations | Validates request/response schemas, error handling |
| C | Validation Rules | Validates rule completeness, consistency |
| D | All Above | Comprehensive protocol quality check |

**Defaults if no interaction**:
- Focus: Entity Definitions + Operations
- Audience: Protocol designer (self-review)
- Depth: Standard

### 3. Load protocol context

**Read from**:
- `specs/protocol/XXX-name/spec.md` (REQUIRED)
- `/memory/constitution.md` (REQUIRED)
- `specs/protocol/XXX-name/checklists/` (REQUIRED - check existing checklists)
- `specs/protocol/XXX-name/examples/` (if exists)
- `specs/protocol/XXX-name/README.md` (if exists)

**DO NOT load** (these are toolkit-specific):
- âŒ plan.md (toolkit architecture)
- âŒ tasks.md (implementation tasks)
- âŒ Any files in `specs/toolkit/`

### 4. Generate or update checklist

#### Mode A: **new** mode (default if no existing checklist)

**Create**:
- Directory: `specs/protocol/XXX-name/checklists/` (if not exists)
- Filename: `[domain].md` (e.g., `entity-design.md`, `operations.md`, `validation-rules.md`)
- Format: Sequential IDs starting from CHK001

#### Mode B: **update** mode (if checklist exists)

**Actions**:
1. Read existing checklist structure
2. Preserve all existing:
   - Item IDs (CHK001, CHK002, ...)
   - Categories
   - Evidence sections
   - Previous iteration results
3. Update:
   - âœ… Pass / âš ï¸ Partial / âŒ Missing status
   - Evidence with new findings
4. Add **new section** at end:
   ```markdown
   ## ğŸ“Š Iteration N: [Date]
   
   ### Changes Since Last Check
   - [List protocol improvements]
   
   ### Updated Scores
   - [Show before/after comparison]
   
   ### New Issues Found
   - [New checklist items if needed]
   ```

#### Mode C: **append** mode (different focus)

**Actions**:
1. Create new checklist file with different filename
2. Reference existing checklist: "See also: [existing-checklist].md"
3. Focus on new aspect (e.g., existing = entities, new = operations)

**Checklist Categories** (for protocol specs):

#### **Entity Definition Quality**
Test if protocol entities are complete, clear, and consistent:
- Are all protocol entities clearly defined with purpose? [Completeness]
- Are all entity fields defined with explicit types? [Completeness]
- Are required vs optional fields clearly specified? [Clarity]
- Are field descriptions specific and measurable? [Clarity]
- Are field constraints documented (enum, format, range)? [Completeness]
- Are example values provided for all entities? [Coverage]
- Are entity relationships documented? [Completeness]

#### **Operation Specification Quality**
Test if protocol operations are completely specified:
- Are all protocol operations listed with clear purposes? [Completeness]
- Are request schemas defined for all operations? [Completeness]
- Are response schemas defined for all operations? [Completeness]
- Are success response formats documented? [Completeness]
- Are error response formats documented? [Completeness]
- Are operation constraints specified (timeouts, retries)? [Completeness]
- Are operation examples provided (success and error)? [Coverage]

#### **Validation Rules Quality**
Test if protocol validation rules are specified:
- Are structural validation rules defined? [Completeness]
- Are semantic validation rules specified? [Completeness]
- Are domain-specific validation rules documented? [Coverage]
- Is validation logic consistent across similar fields? [Consistency]
- Are validation error formats specified? [Completeness]
- Are validation error codes defined? [Completeness]

#### **Error Handling Quality**
Test if protocol error handling is comprehensive:
- Are all error codes defined? [Completeness]
- Are error response formats consistent? [Consistency]
- Are error messages descriptive and actionable? [Clarity]
- Are error scenarios documented for each operation? [Coverage]
- Are recovery strategies specified? [Completeness]

#### **Protocol Examples Quality**
Test if protocol examples are adequate:
- Are examples provided for all entities? [Coverage]
- Are examples provided for all operations? [Coverage]
- Do examples demonstrate typical use cases? [Coverage]
- Do examples cover error scenarios? [Coverage]
- Are examples valid against protocol schemas? [Consistency]

#### **Schema Consistency**
Test if protocol schemas are consistent:
- Is field naming consistent across entities (camelCase vs snake_case)? [Consistency]
- Are type definitions consistent across entities? [Consistency]
- Are required field patterns consistent? [Consistency]
- Are validation rules consistent across similar fields? [Consistency]

#### **Constitution Alignment**
Test if protocol follows constitution principles:
- Does entity design follow Entity-First principle (3-5 core fields)? [Consistency, Constitution Â§I]
- Are field names self-explanatory? [Clarity, Constitution]
- Is protocol minimal and extensible? [Completeness, Constitution]
- Are specifications AI-friendly (clear descriptions)? [Clarity, Constitution]
- Are domain standards followed? [Consistency, Constitution]

#### **Ambiguities & Gaps**
Test for protocol specification issues:
- Are vague terms quantified ("valid", "appropriate")? [Ambiguity]
- Are conflicting requirements identified? [Conflict]
- Are missing definitions noted? [Gap]
- Are unresolved questions marked (TODO, TBD)? [Ambiguity]

### 5. Checklist Item Structure

**Pattern**:
```
- [ ] CHK### - [Question about protocol quality]? [Quality Dimension, Traceability]
```

**Quality Dimensions**:
- [Completeness] - Are all protocol elements defined?
- [Clarity] - Are protocol elements specific and unambiguous?
- [Consistency] - Do protocol elements align?
- [Measurability] - Can protocol rules be verified?
- [Coverage] - Are all scenarios addressed?
- [Gap] - Is something missing?
- [Ambiguity] - Is something unclear?
- [Conflict] - Do elements contradict?

**Traceability Markers**:
- [Spec Â§Section] - References spec.md section
- [Constitution Â§Principle] - References constitution principle
- [Gap] - Missing protocol element
- [Ambiguity] - Unclear protocol element
- [Conflict] - Conflicting protocol elements

### 6. Example Checklist Items

#### Entity Definitions (`entity-design.md`)

```markdown
- [ ] CHK001 - Are all protocol entities clearly defined with purpose statements? [Completeness, Spec Â§Entities]
- [ ] CHK002 - Are all entity fields defined with explicit types (string, number, boolean, array, object)? [Completeness, Spec Â§Entities]
- [ ] CHK003 - Is the distinction between required and optional fields clearly specified? [Clarity, Spec Â§Entities]
- [ ] CHK004 - Are field descriptions specific enough to understand protocol semantics? [Clarity, Spec Â§Entities]
- [ ] CHK005 - Are field constraints documented (enum values, format specifications, ranges)? [Completeness, Spec Â§Entities]
- [ ] CHK006 - Are example values provided for every entity field? [Coverage, Spec Â§Entities]
- [ ] CHK007 - Are entity relationships (references, dependencies) clearly defined? [Completeness, Spec Â§Entities]
- [ ] CHK008 - Does entity design follow Entity-First principle (3-5 core fields)? [Consistency, Constitution Â§I]
- [ ] CHK009 - Are entity field names self-explanatory and consistent? [Clarity, Constitution]
- [ ] CHK010 - Are domain-specific field constraints documented? [Coverage, Spec Â§Domain Constraints]
```

#### Operations (`operations.md`)

```markdown
- [ ] CHK001 - Are all protocol operations listed with clear purpose statements? [Completeness, Spec Â§Operations]
- [ ] CHK002 - Are request schemas defined for all operations? [Completeness, Spec Â§Operations]
- [ ] CHK003 - Are response schemas defined for all operations? [Completeness, Spec Â§Operations]
- [ ] CHK004 - Are success response formats documented with examples? [Completeness, Spec Â§Operations]
- [ ] CHK005 - Are error response formats documented with examples? [Completeness, Spec Â§Operations]
- [ ] CHK006 - Are operation constraints specified (timeouts, rate limits, retries)? [Completeness, Spec Â§Operations]
- [ ] CHK007 - Are operation examples provided for success cases? [Coverage, Spec Â§Examples]
- [ ] CHK008 - Are operation examples provided for error cases? [Coverage, Spec Â§Examples]
- [ ] CHK009 - Is the operation naming convention consistent? [Consistency, Spec Â§Operations]
- [ ] CHK010 - Are operation dependencies documented? [Completeness, Spec Â§Operations]
```

#### Validation Rules (`validation.md`)

```markdown
- [ ] CHK001 - Are structural validation rules (type, required) explicitly defined? [Completeness, Spec Â§Validation Rules]
- [ ] CHK002 - Are semantic validation rules (cross-field, logic) specified? [Completeness, Spec Â§Validation Rules]
- [ ] CHK003 - Are domain-specific validation rules documented with rationale? [Coverage, Spec Â§Domain Validation]
- [ ] CHK004 - Is error message format specified for validation failures? [Clarity, Spec Â§Validation Rules]
- [ ] CHK005 - Are validation error codes defined? [Completeness, Spec Â§Error Codes]
- [ ] CHK006 - Is validation logic consistent across similar fields? [Consistency, Spec Â§Validation Rules]
- [ ] CHK007 - Are validation rules testable and objective? [Measurability, Spec Â§Validation Rules]
- [ ] CHK008 - Are validation edge cases (empty, null, invalid) specified? [Coverage, Gap]
- [ ] CHK009 - Can validation rules be objectively verified? [Measurability, Spec Â§Validation Rules]
- [ ] CHK010 - Are validation examples provided? [Coverage, Spec Â§Examples]
```

#### Error Handling (`error-handling.md`)

```markdown
- [ ] CHK001 - Are all protocol error codes defined with clear meanings? [Completeness, Spec Â§Error Codes]
- [ ] CHK002 - Are error response formats consistent across operations? [Consistency, Spec Â§Error Handling]
- [ ] CHK003 - Are error messages descriptive and actionable? [Clarity, Spec Â§Error Messages]
- [ ] CHK004 - Are error scenarios documented for each operation? [Coverage, Spec Â§Operations]
- [ ] CHK005 - Are recovery strategies specified for errors? [Completeness, Spec Â§Error Handling]
- [ ] CHK006 - Are error examples provided for each error code? [Coverage, Spec Â§Examples]
- [ ] CHK007 - Are error messages AI-friendly with fix suggestions? [Clarity, Constitution]
- [ ] CHK008 - Are error severity levels defined (critical, warning, info)? [Completeness, Spec Â§Error Handling]
- [ ] CHK009 - Are error code ranges documented (e.g., E001-E099 for validation)? [Completeness, Spec Â§Error Codes]
- [ ] CHK010 - Is error handling consistent with domain standards? [Consistency, Constitution]
```

#### Examples (`examples.md`)

```markdown
- [ ] CHK001 - Are examples provided for all protocol entities? [Coverage, Spec Â§Examples]
- [ ] CHK002 - Are examples provided for all protocol operations? [Coverage, Spec Â§Examples]
- [ ] CHK003 - Do entity examples include all required fields? [Completeness, Spec Â§Examples]
- [ ] CHK004 - Do operation examples show typical use cases? [Coverage, Spec Â§Examples]
- [ ] CHK005 - Do examples cover error scenarios? [Coverage, Spec Â§Examples]
- [ ] CHK006 - Are examples valid against protocol schemas? [Consistency, Spec Â§Examples]
- [ ] CHK007 - Are complex scenarios illustrated with examples? [Coverage, Spec Â§Examples]
- [ ] CHK008 - Do examples demonstrate edge cases? [Coverage, Gap]
- [ ] CHK009 - Are example formats consistent (JSON, YAML, etc.)? [Consistency, Spec Â§Examples]
- [ ] CHK010 - Are examples self-contained and executable? [Completeness, Spec Â§Examples]
```

#### Constitution Alignment (`constitution.md`)

```markdown
- [ ] CHK001 - Does entity design follow Entity-First principle (3-5 core fields)? [Consistency, Constitution Â§I]
- [ ] CHK002 - Are entity field names self-explanatory? [Clarity, Constitution]
- [ ] CHK003 - Is protocol minimal (only essential operations)? [Consistency, Constitution]
- [ ] CHK004 - Is protocol extensible (supports future additions)? [Consistency, Constitution]
- [ ] CHK005 - Are specifications AI-friendly (clear descriptions, examples)? [Clarity, Constitution]
- [ ] CHK006 - Are domain standards followed (RFCs, conventions)? [Consistency, Constitution]
- [ ] CHK007 - Are all constitution principles addressed in protocol? [Completeness, Constitution]
- [ ] CHK008 - Are any principle violations explicitly justified? [Traceability, Constitution]
- [ ] CHK009 - Does protocol avoid over-engineering (progressive enhancement)? [Consistency, Constitution]
- [ ] CHK010 - Is constitution referenced in design decisions? [Traceability, Spec]
```

### 7. Anti-Examples: What NOT To Do

**âŒ WRONG - Testing implementation**:
```markdown
- [ ] CHK001 - Verify toolkit parser handles protocol correctly
- [ ] CHK002 - Test toolkit validator catches protocol violations
- [ ] CHK003 - Confirm toolkit CLI works with protocol
```

**âœ… CORRECT - Testing protocol specification quality**:
```markdown
- [ ] CHK001 - Are protocol parsing requirements specified? [Completeness, Spec Â§Parser Requirements]
- [ ] CHK002 - Are protocol validation rules documented? [Completeness, Spec Â§Validation Rules]
- [ ] CHK003 - Are protocol CLI interactions defined? [Completeness, Spec Â§Protocol Interface]
```

### 8. Write checklist file

- Write to `specs/protocol/XXX-name/checklists/[domain].md`
- Use checklist-template structure
- Include metadata (purpose, created date, spec reference)
- Group items by category
- Number sequentially (CHK001, CHK002, ...)

### 9. Report completion

#### For **new** mode:

```
âœ… Checklist generated: entity-design.md

ğŸ“‹ Summary:
- Focus: Entity Definition Quality
- Items: 10
- Categories: 3
- Traceability: 100% (all items reference spec/constitution)

ğŸ“ Location: specs/protocol/XXX-name/checklists/entity-design.md

ğŸ¯ Purpose:
This checklist validates the quality of protocol entity definitions in spec.md.
It does NOT test if toolkit implements protocol, but whether the protocol specification is:
- Complete (all entities defined)
- Clear (types, constraints explicit)
- Consistent (follows constitution)
- Measurable (examples provided)

ğŸ”„ Next steps:
1. Review checklist items
2. Update spec.md to address gaps
3. Re-run /metaspec.sds.clarify if ambiguities found
4. Use /metaspec.sds.analyze for deeper review

ğŸ’¡ Usage:
- During protocol review: Check items before toolkit development
- After protocol draft: Verify protocol completeness
```

#### For **update** mode:

```
âœ… Checklist updated: entity-design.md

ğŸ“Š Iteration N Summary:
- Items updated: 8/10
- Improved: 5 items (âŒ â†’ âš ï¸ or âœ…)
- New issues: 2 items
- Still failing: 1 item

ğŸ“ˆ Progress:
- Previous score: 60% (6/10 passing)
- Current score: 80% (8/10 passing)
- Improvement: +20%

ğŸ“ Location: specs/protocol/XXX-name/checklists/entity-design.md

ğŸ¯ Key improvements detected:
- CHK001: âŒ â†’ âœ… (entities now have purpose statements)
- CHK003: âš ï¸ â†’ âœ… (all fields now typed)
- CHK005: âŒ â†’ âš ï¸ (partial validation rules added)

âš ï¸ Still needs work:
- CHK007: Examples still missing for 2/5 entities

ğŸ”„ Next steps:
1. Review updated scores
2. Address remaining âŒ and âš ï¸ items
3. Re-run checklist after next iteration
- Before release: Ensure protocol is production-ready
```

## Important Notes

1. **Test the protocol spec, not the implementation**
   - Ask: "Is X specified in protocol?" not "Does toolkit implement X?"
   - Focus on protocol quality, not toolkit correctness
   - Check completeness, clarity, consistency

2. **Traceability is mandatory**
   - Every item should reference [Spec Â§X], [Gap], [Constitution Â§Y]
   - Minimum 80% items with traceability markers
   - Makes it easy to find and fix protocol issues

3. **Categories by quality dimension**
   - Group by: Completeness, Clarity, Consistency, Coverage
   - Not by: Implementation area (parser, validator, CLI)
   - Helps identify systematic protocol quality issues

4. **Focus on protocol-specific concerns**
   - Entity definition simplicity
   - Operation specification completeness
   - Validation rule clarity
   - Error handling consistency
   - Constitution alignment

5. **Multiple checklists allowed**
   - `entity-design.md` - Entity definition quality
   - `operations.md` - Operation specification quality
   - `validation.md` - Validation rules quality
   - `error-handling.md` - Error handling completeness
   - `constitution.md` - Constitution alignment
   - `examples.md` - Examples coverage

## Common Checklist Types

| Checklist | Focus | When to Use |
|-----------|-------|-------------|
| `entity-design.md` | Entity definitions | After /metaspec.sds.specify, before toolkit development |
| `operations.md` | Operation specifications | After /metaspec.sds.specify, before toolkit development |
| `validation.md` | Validation rules | After /metaspec.sds.clarify, before toolkit development |
| `error-handling.md` | Error handling | After /metaspec.sds.specify, before toolkit development |
| `constitution.md` | Constitution alignment | After /metaspec.sds.analyze, before toolkit development |
| `examples.md` | Examples coverage | After /metaspec.sds.specify, before release |


