from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional, Tuple

CELL_MARK_RE = re.compile(r"(?m)^#\s*%%[^\n]*\n")
EXPORT_TAG_RE = re.compile(r"(?m)^[ \t]*#\s*export\b.*\n")
JUPYTEXT_HEADER_RE = re.compile(r"(?ms)^#\s*---.*?^#\s*---\n")


@dataclass
class ExportConfig:
    outdir: Path = Path("exports")
    project_root: Optional[Path] = None
    keep_magics: bool = False
    dry_run: bool = False
    fail_on_empty: bool = False

    def resolved(self) -> "ExportConfig":
        cfg = ExportConfig(**vars(self))
        cfg.outdir = cfg.outdir.resolve()
        if cfg.project_root is None:
            cfg.project_root = auto_project_root()
        else:
            cfg.project_root = cfg.project_root.resolve()
        return cfg


# --- public API -------------------------------------------------------------


def export_tree(root: Path | str, cfg: ExportConfig) -> list[Tuple[Path, str]]:
    """Export all candidate files under *root*.

    Returns a list of (output_path, text) for what would be/was written.
    """
    cfg = cfg.resolved()
    root = Path(root).resolve()
    outputs: list[Tuple[Path, str]] = []

    for p in iter_candidates(root):
        outp, text = export_file(p, cfg)
        if text is None:
            continue
        outputs.append((outp, text))
    return outputs


def export_file(path: Path | str, cfg: ExportConfig) -> Tuple[Path, Optional[str]]:
    """Export a single file. Returns (output_path, text or None if skipped)."""
    cfg = cfg.resolved()
    src = Path(path).resolve()

    if not src.is_file():
        raise FileNotFoundError(src)

    if src.suffix != ".py":
        return (dst_path_for(src, cfg), None)

    text = src.read_text(encoding="utf-8")

    # Quickly skip if there's no percent cell markers (not a jupytext percent file)
    if not has_percent_cells(text):
        return (dst_path_for(src, cfg), None)

    exported = extract_exported_text(text, keep_magics=cfg.keep_magics)
    if not exported:
        if cfg.fail_on_empty:
            raise RuntimeError(f"No #export cells found in {src}")
        return (dst_path_for(src, cfg), None)

    banner = (
        "# This file was auto-generated by jtexport.\n"
        f"# Source: {rel_to_project(src, cfg.project_root)}\n\n"
    )
    final_text = banner + exported + ("\n" if not exported.endswith("\n") else "")

    dst = dst_path_for(src, cfg)
    if not cfg.dry_run:
        dst.parent.mkdir(parents=True, exist_ok=True)
        dst.write_text(final_text, encoding="utf-8")
    return dst, final_text


# --- helpers ----------------------------------------------------------------


def auto_project_root(start: Optional[Path] = None) -> Path:
    """Find project root by walking upward for .git or pyproject.toml; fallback to CWD."""
    p = (start or Path.cwd()).resolve()
    sentinels = {".git", "pyproject.toml"}
    for q in [p, *p.parents]:
        for s in sentinels:
            if (q / s).exists():
                return q
    return p


def iter_candidates(root: Path) -> Iterable[Path]:
    for p in root.rglob("*.py"):
        # skip typical virtualenv & build dirs
        if any(
            seg in {".venv", "venv", "env", "build", "dist", "exports", ".git"}
            for seg in p.parts
        ):
            continue
        yield p


def has_percent_cells(text: str) -> bool:
    return bool(CELL_MARK_RE.search(text))


def split_cells(text: str) -> list[str]:
    # Remove the top jupytext YAML header if present so the preamble doesn't become a cell
    text = JUPYTEXT_HEADER_RE.sub("", text)
    # Split on the *line* that declares a cell; retain only body text after each marker
    # re.split returns the chunks after the marker lines because the pattern consumes the newline
    chunks = CELL_MARK_RE.split(text)
    # The first chunk is preamble (before the first cell) â€” ignore it for export purposes
    return chunks[1:] if len(chunks) > 1 else []


def strip_export_tag(cell: str) -> str:
    # Remove exactly one leading `#export` line (allow spaces/tabs before '#')
    return EXPORT_TAG_RE.sub("", cell, count=1)


def is_export_cell(cell: str) -> bool:
    # Consider it an export cell if it has `#export` as a standalone comment line anywhere
    return bool(EXPORT_TAG_RE.search(cell))


def strip_magics(cell: str) -> str:
    # Drop simple IPython one-liners like %time, !pip, %%bash etc., conservatively
    out_lines = []
    for line in cell.splitlines():
        s = line.lstrip()
        if s.startswith("%") or s.startswith("!"):
            continue
        out_lines.append(line)
    return "\n".join(out_lines) + ("\n" if cell.endswith("\n") else "")


def clean_cell(cell: str, keep_magics: bool) -> str:
    cell = strip_export_tag(cell)
    if not keep_magics:
        cell = strip_magics(cell)
    return cell


def extract_exported_text(text: str, *, keep_magics: bool = False) -> str:
    cells = split_cells(text)
    exported: list[str] = []
    for c in cells:
        if is_export_cell(c):
            cleaned = clean_cell(c, keep_magics=keep_magics)
            exported.append(cleaned.rstrip() + "\n\n")
    return "".join(exported).rstrip() + ("\n" if exported else "")


def rel_to_project(path: Path, project_root: Optional[Path]) -> Path | str:
    try:
        return path.resolve().relative_to((project_root or Path.cwd()).resolve())
    except Exception:
        return path.name if path.is_file() else path


def dst_path_for(src: Path, cfg: ExportConfig) -> Path:
    rel = rel_to_project(src, cfg.project_root)
    return cfg.outdir / Path(rel)
