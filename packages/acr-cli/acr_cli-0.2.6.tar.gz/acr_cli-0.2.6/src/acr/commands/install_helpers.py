from typing import Optional

from pathlib import Path



def make_pre_commit_script(python_exec: Optional[str], run_strict: bool = False) -> str:
    """
    Produce a robust POSIX shell pre-commit script body that:
      - prefers `python` then `python3` from PATH;
      - falls back to the explicit python_exec if provided (safely escaped);
      - passes `--strict` to the review command when run_strict is True.
    The returned string is a complete shell script body (without shebang),
    ready to be written into the hook file (the installer will add shebang and make executable).
    """
    strict_arg = "-s" if run_strict else ""
    # escape single quotes to safely embed into single-quoted shell literal
    py_fallback = (python_exec or "").replace("'", "'\"'\"'")

    return f"""
        # Auto-generated by ACR - pre-commit wrapper
        # Tries: python -> python3 -> fallback
        STRICT_ARG='{strict_arg}'
        PY_FALLBACK='{py_fallback}'

        run_with() {{
            # $1 is python executable to run
            "$1" -m src.acr.cli review staged --output json $STRICT_ARG
            return $?
        }}

        # Prefer python on PATH
        if command -v python >/dev/null 2>&1; then
            run_with python
            rc=$?
        elif command -v python3 >/dev/null 2>&1; then
            run_with python3
            rc=$?
        else
            rc=127
        fi

        # If initial attempts failed and a fallback was given, try more approaches
        if [ "$rc" -ne 0 ] && [ -n "$PY_FALLBACK" ]; then
            # 1) If cygpath exists and fallback looks like Windows drive path, convert it
            if command -v cygpath >/dev/null 2>&1 && printf '%s' "$PY_FALLBACK" | grep -E '^[A-Za-z]:\\\\' >/dev/null 2>&1; then
                UPATH=$(cygpath -u "$PY_FALLBACK" 2>/dev/null || echo "$PY_FALLBACK")
                run_with "$UPATH"
                rc=$?
            fi

            # 2) Try replacing backslashes with forward slashes (C:\a\b -> C:/a/b)
            if [ "$rc" -ne 0 ] && printf '%s' "$PY_FALLBACK" | grep -q '\\\\'; then
                POSIX=$(printf '%s' "$PY_FALLBACK" | sed 's#\\\\#/#g')
                run_with "$POSIX"
                rc=$?
            fi

            # 3) Try fallback as-is (quoted)
            if [ "$rc" -ne 0 ]; then
                run_with "$PY_FALLBACK"
                rc=$?
            fi

            # 4) If still failing and cmd.exe exists (Git for Windows), try invoking via cmd.exe
            if [ "$rc" -ne 0 ] && command -v cmd.exe >/dev/null 2>&1; then
                # use cmd.exe to run the Windows python; ignore its stdout/stderr to avoid noise
                cmd.exe /c "\"$PY_FALLBACK\" -m src.acr.cli review staged --output json $STRICT_ARG"
                rc=$?
            fi
        fi

        if [ "$rc" -ne 0 ]; then
            if [ "$rc" -eq 127 ]; then
                echo "❌ ACR pre-commit: no python interpreter found (tried python, python3)." >&2
            else
                echo "❌ ACR pre-commit: staged checks failed (exit code $rc). Fix issues and re-stage." >&2
            fi
            exit $rc
        fi

        exit 0
    """


def make_pre_push_script(python_exec: Optional[str], run_strict: bool = False) -> str:
    """
    Produce a robust POSIX shell pre-push script body.
    Same behavior as pre-commit script, but calls `review current`.
    By default the hook reports issues but does not block push (preserves previous behavior).
    """
    strict_arg = "-s" if run_strict else ""
    py_fallback = (python_exec or "").replace("'", "'\"'\"'")

    return f"""
        # Auto-generated by ACR - pre-push wrapper
        STRICT_ARG='{strict_arg}'
        PY_FALLBACK='{py_fallback}'

        run_with() {{
            "$1" -m src.acr.cli review current --output json $STRICT_ARG
            return $?
        }}

        if command -v python >/dev/null 2>&1; then
            run_with python
            rc=$?
        elif command -v python3 >/dev/null 2>&1; then
            run_with python3
            rc=$?
        else
            rc=127
        fi

        if [ "$rc" -ne 0 ] && [ -n "$PY_FALLBACK" ]; then
            if command -v cygpath >/dev/null 2>&1 && printf '%s' "$PY_FALLBACK" | grep -E '^[A-Za-z]:\\\\' >/dev/null 2>&1; then
                UPATH=$(cygpath -u "$PY_FALLBACK" 2>/dev/null || echo "$PY_FALLBACK")
                run_with "$UPATH"
                rc=$?
            fi

            if [ "$rc" -ne 0 ] && printf '%s' "$PY_FALLBACK" | grep -q '\\\\'; then
                POSIX=$(printf '%s' "$PY_FALLBACK" | sed 's#\\\\#/#g')
                run_with "$POSIX"
                rc=$?
            fi

            if [ "$rc" -ne 0 ]; then
                run_with "$PY_FALLBACK"
                rc=$?
            fi

            if [ "$rc" -ne 0 ] && command -v cmd.exe >/dev/null 2>&1; then
                cmd.exe /c "\"$PY_FALLBACK\" -m src.acr.cli review current --output json $STRICT_ARG"
                rc=$?
            fi
        fi

        if [ "$rc" -ne 0 ]; then
            if [ "$rc" -eq 127 ]; then
                echo "⚠️ ACR pre-push: no python interpreter found (tried python, python3)." >&2
            else
                echo "⚠️ ACR pre-push: review reported issues (exit code $rc)." >&2
            fi
            exit $rc
        fi

        exit 0
    """


def _ensure_repo_path(repo_path: Optional[str]) -> Path:
    if repo_path:
        return Path(repo_path).expanduser().resolve()

    return Path(".").resolve()