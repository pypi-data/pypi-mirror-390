# Generated by 'python3 -m parameter_persistence.generate_models'

from __future__ import annotations

from typing import Any, List, Optional

from pydantic import BaseModel, Field


class WebBridgeParameters(BaseModel):
    address: Optional[str] = Field(
        None, description="The host address to bind the WebSocket server to"
    )
    asset_uri_allowlist: Optional[List[str]] = Field(
        None,
        description="List of regular expressions (ECMAScript) of whitelisted parameter names.",
    )
    best_effort_qos_send_buffer_limit: Optional[int] = Field(
        None,
        description="Connection send buffer limit in bytes for 'best_effort' messages",
    )
    best_effort_qos_topic_whitelist: Optional[List[str]] = Field(
        None,
        description="List of regular expressions (ECMAScript) for topics that should be forced to use 'best_effort' QoS. Unmatched topics will use 'reliable' QoS if ALL publishers are 'reliable', 'best_effort' if any publishers are 'best_effort'.",
    )
    capabilities: Optional[List[str]] = Field(None, description="Server capabilities")
    certfile: Optional[str] = Field(None, description="Path to the certificate to use for TLS")
    client_topic_whitelist: Optional[List[str]] = Field(
        None,
        description="List of regular expressions (ECMAScript) of whitelisted parameter names.",
    )
    disable_load_message: Optional[bool] = Field(
        None,
        description="Do not publish as loaned message when publishing a client message",
    )
    include_hidden: Optional[bool] = Field(None, description="Include hidden topics and services")
    keyfile: Optional[str] = Field(None, description="Path to the private key to use for TLS")
    max_qos_depth: Optional[int] = Field(
        None, description="Maximum depth used for the QoS profile of subscriptions."
    )
    min_qos_depth: Optional[int] = Field(
        None, description="Minimum depth used for the QoS profile of subscriptions."
    )
    min_qos_topic_depths: Optional[List[int]] = Field(
        None,
        description="List of depths to use on corresponding min qos pattern (matching index)",
    )
    min_qos_topic_patterns: Optional[List[str]] = Field(
        None,
        description="List of regex patterns to use corresponding min qos depth for (matching index)",
    )
    param_whitelist: Optional[List[str]] = Field(
        None,
        description="List of regular expressions (ECMAScript) of whitelisted parameter names.",
    )
    port: Optional[int] = Field(None, description="The TCP port to bind the WebSocket server to")
    send_buffer_limit: Optional[int] = Field(
        None,
        description="Connection send buffer limit in bytes. Messages will be dropped when a connection's send buffer reaches this limit to avoid a queue of outdated messages building up.",
    )
    service_whitelist: Optional[List[str]] = Field(
        None,
        description="List of regular expressions (ECMAScript) of whitelisted service names.",
    )
    tls: Optional[bool] = Field(
        None, description="Use Transport Layer Security for encrypted communication"
    )
    topic_throttle_patterns: Optional[List[str]] = Field(
        None,
        description="List of regex patterns to throttle by corresponding rate (matching index)",
    )
    topic_throttle_rates: Optional[List[float]] = Field(
        None,
        description="List of rates to throttle corresponding (matching index) patterns by. Represents messages per second",
    )
    topic_whitelist: Optional[List[str]] = Field(
        None,
        description="List of regular expressions (ECMAScript) of whitelisted topic names.",
    )
    use_compression: Optional[bool] = Field(
        None,
        description="Use websocket compression (permessage-deflate). Suited for connections with smaller bandwidth, at the cost of additional CPU load.",
    )


class Track(BaseModel):
    stale_timeout: Optional[float] = Field(
        None,
        description="Time in seconds before a track is considered stale and removed",
    )
    spawn_radius: Optional[float] = Field(
        None, description="Radius in meters around the vessel to spawn tracks"
    )
    sources_enabled: Optional[List[str]] = Field(
        None, description="The sources of tracks that will spawn vessels in MIS-SIM"
    )


class Oscillation(BaseModel):
    period: Optional[float] = Field(None, description="in seconds")
    amplitude: Optional[float] = Field(None, description="in m/s")


class OceanDrift(BaseModel):
    speed: Optional[float] = Field(None, description="in m/s")
    direction: Optional[float] = Field(None, description="degrees clockwise from north")
    oscillation: Optional[Oscillation] = None


class VesselManagerParameters(BaseModel):
    enabled: Optional[bool] = Field(
        None, description="Whether to enable the vessel manager or not"
    )
    vessels: Optional[str] = Field(None, description="List of vessels")
    hifi_mode: Optional[bool] = Field(
        None, description="Should we use the low-fidelity topic suffix"
    )
    objects_publish_rate: Optional[float] = Field(
        None, description="Rate at which to publish objects in Hz"
    )
    track: Optional[Track] = None
    ocean_drift: Optional[OceanDrift] = None


class DiagnosticUpdater(BaseModel):
    period: Optional[float] = Field(None, description="")
    use_fqn: Optional[bool] = Field(None, description="")


class StateTimer(BaseModel):
    publish_period: Optional[int] = Field(
        None, description="Period (ms) to publish playback state updates."
    )


class Storage(BaseModel):
    directory: Optional[str] = Field(None, description="Directory to play recordings from.")
    plugin_name: Optional[Any] = Field(None, description="Storage plugin to use.")


class DataPlayerParameters(BaseModel):
    diagnostic_updater: Optional[DiagnosticUpdater] = None
    state_timer: Optional[StateTimer] = None
    storage: Optional[Storage] = None


class Buffer(BaseModel):
    enabled: Optional[bool] = Field(
        None,
        description="Enables a recording buffer to capture historical data prior to recording requests.",
    )
    size: Optional[int] = Field(None, description="Size (in bytes) of the recording buffer.")


class StateTimer1(BaseModel):
    publish_period: Optional[int] = Field(
        None, description="Period (ms) to publish recording state updates."
    )


class Storage1(BaseModel):
    critical_threshold: Optional[float] = Field(
        None,
        description="Triggers an error diagnostic and prevents recording if storage usage is above this threshold. Bound to limits [0.0, 1.0]",
    )
    directory: Optional[str] = Field(None, description="Directory where recordings will be saved.")
    plugin_name: Optional[Any] = Field(None, description="Storage plugin to use.")
    plugin_profile: Optional[Any] = Field(
        None,
        description="Storage plugin preset profile to use to determine write speed and compression ratio. Only used for mcap storage plugin.",
    )
    warning_threshold: Optional[float] = Field(
        None,
        description="Triggers a warning diagnostic if storage usage is above the threshold. Bound to limits [0.0, 1.0]",
    )


class Topics(BaseModel):
    exclude_regexs: Optional[List[str]] = Field(
        None,
        description="An array of regex patterns to use for topic EXCLUSION from the recording.",
    )
    include_regexs: Optional[List[str]] = Field(
        None,
        description="An array of regex patterns to use for topic INCLUSION in the recording.",
    )


class TriggerTopic(BaseModel):
    enabled: Optional[bool] = Field(
        None,
        description="Enables a trigger topic that can be used to start/stop recordings (example_interfaces/Bool).",
    )


class DataRecorderParameters(BaseModel):
    buffer: Optional[Buffer] = None
    diagnostic_updater: Optional[DiagnosticUpdater] = None
    state_timer: Optional[StateTimer1] = None
    storage: Optional[Storage1] = None
    topics: Optional[Topics] = None
    trigger_topic: Optional[TriggerTopic] = None


class Storage2(BaseModel):
    directory: Optional[str] = Field(None, description="Directory containing recording bag files.")


class UploadQueue(BaseModel):
    size: Optional[int] = Field(None, description="Max number of items in the upload queue.")


class Config(BaseModel):
    access_key_id: Optional[str] = Field(None, description="AWS access key ID")
    secret_access_key: Optional[str] = Field(None, description="AWS secret access key")
    region: Optional[str] = Field(None, description="AWS region")
    endpoint: Optional[str] = Field(None, description="AWS S3 endpoint URL")


class AwsS3(BaseModel):
    config: Optional[Config] = Field(
        None,
        description="JSON schema used to configure and authenticate the remote destination.",
    )


class Config1(BaseModel):
    sas_url: Optional[str] = Field(None, description="Access URL including SAS token")


class AzureBlob(BaseModel):
    config: Optional[Config1] = Field(
        None,
        description="JSON schema used to configure and authenticate the remote destination.",
    )


class Config2(BaseModel):
    account: Optional[str] = Field(None, description="OneDrive account name")
    client_id: Optional[str] = Field(None, description="Client ID for OneDrive")
    client_secret: Optional[str] = Field(None, description="Client secret for OneDrive")
    tenant: Optional[str] = Field(None, description="Tenant ID for OneDrive")


class MicrosoftOnedrive(BaseModel):
    config: Optional[Config2] = Field(
        None,
        description="JSON schema used to configure and authenticate the remote destination.",
    )


class Config3(BaseModel):
    host: Optional[str] = Field(None, description="SFTP host")
    user: Optional[str] = Field(None, description="Host username")
    pass_: Optional[str] = Field(None, alias="pass", description="Host password")


class Sftp(BaseModel):
    config: Optional[Config3] = Field(
        None,
        description="JSON schema used to configure and authenticate the remote destination.",
    )


class UploadDestination(BaseModel):
    name: Optional[str] = Field(None, description="Identifying name of the upload destination.")
    type: Optional[Any] = Field(None, description="Type of upload destination")
    upload_path: Optional[str] = Field(
        None, description="Path at the destination to upload files to."
    )
    aws_s3: Optional[AwsS3] = None
    azure_blob: Optional[AzureBlob] = None
    microsoft_onedrive: Optional[MicrosoftOnedrive] = None
    sftp: Optional[Sftp] = None


class DataHubParameters(BaseModel):
    port: Optional[int] = Field(None, description="Port for the HTTP server.")
    storage: Optional[Storage2] = None
    upload_queue: Optional[UploadQueue] = None
    upload_destination: Optional[UploadDestination] = None
    diagnostic_updater: Optional[DiagnosticUpdater] = None


class SimulatedClockParameters(BaseModel):
    enabled: Optional[bool] = Field(
        None, description="Whether to enable the simulated clock or not"
    )
    sim_speed: Optional[float] = Field(None, description="Speed at which to run the simulation")
    publish_rate: Optional[float] = Field(
        None, description="Rate at which to publish the clock at?"
    )


class HifiVesselManagerParameters(BaseModel):
    replay_mode: Optional[bool] = Field(None, description="Is the node in replay mode?")


class ScenarioRunnerParameters(BaseModel):
    scenarios: Optional[List[str]] = Field(None, description="List of scenarios")


class NodeConfigurationModel(BaseModel):
    node_name_regex: str = Field(..., title="Node Name Regex")
    parameter_name_regexes: List[str] = Field(..., title="Parameter Name Regexes")


class ParameterPersistenceParameters(BaseModel):
    params_path: Optional[str] = Field(
        None, description="Path to the file where the parameters are stored"
    )
    file_header: Optional[str] = Field(
        None, description="A message to add to the top of the params file"
    )
    path_within_file: Optional[str] = Field(
        None, description="Path within the file to store the parameters"
    )
    persistent_parameters: Optional[List[NodeConfigurationModel]] = Field(
        None, description="Regex describing which parameters should persist"
    )


class LaunchParameters(BaseModel):
    web_bridge: Optional[WebBridgeParameters] = None
    vessel_manager: Optional[VesselManagerParameters] = None
    data_player: Optional[DataPlayerParameters] = None
    data_recorder: Optional[DataRecorderParameters] = None
    data_hub: Optional[DataHubParameters] = None
    simulated_clock: Optional[SimulatedClockParameters] = None
    hifi_vessel_manager: Optional[HifiVesselManagerParameters] = None
    scenario_runner: Optional[ScenarioRunnerParameters] = None
    parameter_persistence: Optional[ParameterPersistenceParameters] = None
