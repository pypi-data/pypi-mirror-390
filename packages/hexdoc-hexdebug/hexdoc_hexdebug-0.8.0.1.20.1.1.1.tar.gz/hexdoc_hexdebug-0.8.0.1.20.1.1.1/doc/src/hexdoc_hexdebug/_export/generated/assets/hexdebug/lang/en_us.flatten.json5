{"item.hexdebug.debugger": "Debugger", "item.hexdebug.quenched_debugger": "Quenched Debugger", "item.hexdebug.evaluator": "Evaluator", "item.hexdebug.quenched_evaluator": "Quenched Evaluator", "block.hexdebug.splicing_table": "Splicing Table", "block.hexdebug.enlightened_splicing_table": "Mindsplice Table", "block.hexdebug.focus_holder": "Focal Frame", "itemGroup.hexdebug": "HexDebug", "text.hexdebug.debugging.connected": "Debug client connected!", "text.hexdebug.debugging.no_session": "Debug session is not running for thread %d.", "text.hexdebug.debugging.not_paused": "Debug session is not paused for thread %d.", "text.hexdebug.debugging.debugger_stopped": "Next Iota: [%d] %s", "text.hexdebug.debugging.illegal_thread": "The item failed, somehow... am I not skilled enough?", "text.hexdebug.debugging.out_of_range": "Debuggee is out of range.", "text.hexdebug.thwack": "Thwack!", "text.hexdebug.splicing_table.button.view_left": "Move View Left", "text.hexdebug.splicing_table.button.view_left_page": "Move View to Previous Page", "text.hexdebug.splicing_table.button.view_left_full": "Move View to Start", "text.hexdebug.splicing_table.button.view_right": "Move View Right", "text.hexdebug.splicing_table.button.view_right_page": "Move View to Next Page", "text.hexdebug.splicing_table.button.view_right_full": "Move View to End", "text.hexdebug.splicing_table.button.cursor_left": "Move Cursor Left", "text.hexdebug.splicing_table.button.cursor_right": "Move Cursor Right", "text.hexdebug.splicing_table.button.expand_selection_left": "Expand Selection Left", "text.hexdebug.splicing_table.button.expand_selection_right": "Expand Selection Right", "text.hexdebug.splicing_table.button.move_selection_left": "Move Selection Left", "text.hexdebug.splicing_table.button.move_selection_right": "Move Selection Right", "text.hexdebug.splicing_table.button.select_none": "Select None", "text.hexdebug.splicing_table.button.select_all": "Select All", "text.hexdebug.splicing_table.button.clear_grid": "Clear Grid", "text.hexdebug.splicing_table.button.nudge_left": "Nudge Left", "text.hexdebug.splicing_table.button.nudge_right": "Nudge Right", "text.hexdebug.splicing_table.button.duplicate": "Duplicate", "text.hexdebug.splicing_table.button.delete": "Delete", "text.hexdebug.splicing_table.button.backspace": "Backspace", "text.hexdebug.splicing_table.button.undo": "Undo", "text.hexdebug.splicing_table.button.redo": "Redo", "text.hexdebug.splicing_table.button.cut": "Cut", "text.hexdebug.splicing_table.button.copy": "Copy", "text.hexdebug.splicing_table.button.paste_verbatim": "Paste (Verbatim)", "text.hexdebug.splicing_table.button.paste_splat": "Paste (Flattened)", "text.hexdebug.splicing_table.button.export": "Export as .hexpattern", "text.hexdebug.splicing_table.button.cast": "Activate Mindsplice Table", "text.hexdebug.splicing_table.button.cast.named": "Activate %s", "text.hexdebug.splicing_table.tooltip.index": "Index: %d", "text.hexdebug.splicing_table.tooltip.depth": "Depth: %d", "text.hexdebug.splicing_table.tooltip.signature": "Signature: %s", "text.hexdebug.splicing_table.tooltip.length": "Length: %d", "text.autoconfig.hexdebug.title": "HexDebug Config", "text.autoconfig.hexdebug.category.client": "Client", "text.autoconfig.hexdebug.category.server": "Server", "text.autoconfig.hexdebug.option.client.openDebugPort": "Open Debug Port", "text.autoconfig.hexdebug.option.client.openDebugPort.@Tooltip": "Whether or not a port should be opened. If false, the Debugger effectively becomes useless.", "text.autoconfig.hexdebug.option.client.debugPort": "Debug Port", "text.autoconfig.hexdebug.option.client.debugPort.@Tooltip": "Port number (1024-65535) to open for the debug client (eg. VSCode) to connect to.", "text.autoconfig.hexdebug.option.client.smartDebuggerSneakScroll": "Smart Debugger Sneak-Scroll", "text.autoconfig.hexdebug.option.client.smartDebuggerSneakScroll.@Tooltip": "If a hex is not currently being debugged and a Debugger is in your main hand, prefer shift-scrolling whatever item is in your offhand (eg. a spellbook).", "text.autoconfig.hexdebug.option.client.debuggerDisplayMode": "Debugger Display Mode", "text.autoconfig.hexdebug.option.client.debuggerDisplayMode.@Tooltip": "Changes when the Debugger should print the next iota to be evaluated.\nDISABLED: Never show Debugger status messages.\nNOT_CONNECTED: Only show Debugger status messages if a debug client is not connected.\nENABLED: Always show Debugger status messages. (default)", "text.autoconfig.hexdebug.option.client.showDebugClientLineNumber": "Show Debug Client Line Number", "text.autoconfig.hexdebug.option.client.showDebugClientLineNumber.@Tooltip": "If true, show the line number (usually 1-indexed) from the debug client (eg. VSCode) in Debugger status messages; otherwise, show the list index (0-indexed).", "text.autoconfig.hexdebug.option.client.splicingTable": "General Splicing Table Options", "text.autoconfig.hexdebug.option.client.splicingTable.invertScrollDirection": "Invert Scroll Direction", "text.autoconfig.hexdebug.option.client.splicingTable.invertScrollDirection.@Tooltip": "Whether scrolling up (as opposed to down) will increase the view index of the Splicing Table, and vice versa.", "text.autoconfig.hexdebug.option.client.splicingTable.enableRainbowBrackets": "Enable Rainbow Brackets", "text.autoconfig.hexdebug.option.client.splicingTable.enableRainbowBrackets.@Tooltip": "If true, tint the outline of Introspection and Retrospection with rainbow colors to help identify matching brackets.", "text.autoconfig.hexdebug.option.client.splicingTable.rainbowBracketColors": "Rainbow Bracket Colors", "text.autoconfig.hexdebug.option.client.splicingTable.showNestedPatternNames": "Show Nested Pattern Names", "text.autoconfig.hexdebug.option.client.splicingTable.showNestedPatternNames.@Tooltip": "If true, for patterns inside of embedded lists, show pattern names in the tooltip instead of the built-in inline pattern display.", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds": "Splicing Table Keybinds", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.@Tooltip": "Keybinds for actions in the Splicing Table GUI.", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.enabled": "Enable Keybinds", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.enabled.@Tooltip": "Enable custom keybinds in the Splicing Table and Mindsplice Table GUIs. If disabled, all other settings in this category are ignored.", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.overrideVanillaArrowKeys": "Override Vanilla Arrow Key Navigation", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.overrideVanillaArrowKeys.@Tooltip": "In the Splicing Table GUI, override the vanilla feature that allows the arrow keys to be used to focus on UI elements. This setting improves usability with the default keybinds, but you may want to disable it if you rely on this feature for accessibility purposes.", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.sendHexicalTelepathy": "Enable Hexical Telepathy", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.sendHexicalTelepathy.@Tooltip": "Fabric-only. If Hexical is installed, enable all telepathy keys in the Splicing Table GUI. Note: If Hexical adds its own support for using telepathy in GUIs, disabling this feature will not disable that.", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.enlightened": "Mindsplice Table", "text.autoconfig.hexdebug.option.client.splicingTableKeybinds.enlightened.@Tooltip": "Keybinds for actions in the Mindsplice Table GUI.", "text.autoconfig.hexdebug.option.server.maxUndoStackSize": "Undo History Size Limit", "text.autoconfig.hexdebug.option.server.maxUndoStackSize.@Tooltip": "Maximum allowed size of the Splicing Table's undo history. To disable the limit, set the value to 0.", "text.autoconfig.hexdebug.option.server.splicingTableMediaCost": "Splicing Table Media Cost", "text.autoconfig.hexdebug.option.server.splicingTableMediaCost.@Tooltip": "How many points of media to consume when performing an action in a Splicing Table.", "text.autoconfig.hexdebug.option.server.splicingTableMaxMedia": "Splicing Table Max Media", "text.autoconfig.hexdebug.option.server.splicingTableMaxMedia.@Tooltip": "How many points of media to consume when performing an action in a Splicing Table.", "text.autoconfig.hexdebug.option.server.splicingTableCastingCooldown": "Mindsplice Table Casting Cooldown", "text.autoconfig.hexdebug.option.server.splicingTableCastingCooldown.@Tooltip": "Cooldown in ticks for the Mindsplice Table's casting button.", "text.autoconfig.hexdebug.option.server.splicingTableAmbit": "Mindsplice Table Ambit", "text.autoconfig.hexdebug.option.server.splicingTableAmbit.@Tooltip": "Ambit radius in blocks for the Mindsplice Table.", "hexcasting.action.hexdebug:const/debugging": "Debugger's Reflection", "hexcasting.action.hexdebug:const/cognitohazard": "Cognitohazard Reflection", "hexcasting.action.hexdebug:breakpoint/before": "Set Breakpoint Before", "hexcasting.action.hexdebug:breakpoint/after": "Set Breakpoint After", "hexcasting.action.hexdebug:craft/debugger": "Craft Debugger", "hexcasting.action.hexdebug:craft/quenched_debugger": "Craft Quenched Debugger", "hexcasting.action.hexdebug:splicing/view_index/read": "Sprocket's Purification", "hexcasting.action.hexdebug:splicing/view_index/write": "Sprocket's Gambit", "hexcasting.action.hexdebug:splicing/selection/read": "Splicer's Decomposition", "hexcasting.action.hexdebug:splicing/selection/write": "Splicer's Gambit", "hexcasting.action.hexdebug:splicing/list/spellbook_index/read": "Projectionist's Purification", "hexcasting.action.hexdebug:splicing/list/spellbook_index/write": "Projectionist's Gambit", "hexcasting.action.hexdebug:splicing/list/spellbook_index/readable": "Shutter's Purification", "hexcasting.action.hexdebug:splicing/clipboard/read": "Compositor's Purification", "hexcasting.action.hexdebug:splicing/clipboard/write": "Compositor's Gambit", "hexcasting.action.hexdebug:splicing/clipboard/readable": "Producer's Purification", "hexcasting.action.hexdebug:splicing/clipboard/writable": "Director's Purification", "hexcasting.action.hexdebug:splicing/clipboard/spellbook_index/read": "Projectionist's Purification II", "hexcasting.action.hexdebug:splicing/clipboard/spellbook_index/write": "Projectionist's Gambit II", "hexcasting.action.hexdebug:splicing/clipboard/spellbook_index/readable": "Shutter's Purification II", "hexcasting.action.hexdebug:splicing/enlightened/hex/read": "Mindsplice Purification", "hexcasting.action.hexdebug:splicing/enlightened/hex/write": "Imbue Mindsplice Table", "hexcasting.action.book.hexdebug:const/cognitohazard": "Cognitohazard Rfln.", "hexcasting.action.book.hexdebug:splicing/list/spellbook_index/read": "Projectionist's Prfn.", "hexcasting.action.book.hexdebug:splicing/clipboard/read": "Compositor's Prfn.", "hexcasting.action.book.hexdebug:splicing/clipboard/spellbook_index/read": "Projectionist's Prfn. II", "hexcasting.action.book.hexdebug:splicing/clipboard/spellbook_index/readable": "Shutter's Prfn. II", "hexcasting.mishap.bad_block.splicing_table": "a Splicing Table", "hexcasting.mishap.bad_block.splicing_table.enlightened": "a Mindsplice Table", "hexcasting.mishap.bad_block.splicing_table.clipboard.read": "a Splicing Table with a readable secondary item", "hexcasting.mishap.bad_block.splicing_table.clipboard.write": "a Splicing Table with a writable secondary item", "hexcasting.mishap.bad_block.splicing_table.clipboard.spellbook": "a Splicing Table with a non-empty spellbook in the secondary item slot", "hexcasting.mishap.bad_block.splicing_table_or_focus_holder": "a Splicing Table or Focal Frame", "hexcasting.mishap.bad_block.splicing_table_or_focus_holder.spellbook": "a Splicing Table or Focal Frame with a non-empty spellbook in the main item slot", "hexcasting.mishap.invalid_value.int.positive_or_null": "a positive integer or null", "hexdebug.tooltip.thread.inactive": "Thread %s", "hexdebug.tooltip.thread.active": "Thread %s (%s)", "hexdebug.tooltip.debugger.step_mode.continue": "Mode: Continue", "hexdebug.tooltip.debugger.step_mode.over": "Mode: Step Over", "hexdebug.tooltip.debugger.step_mode.in": "Mode: Step In", "hexdebug.tooltip.debugger.step_mode.out": "Mode: Step Out", "hexdebug.tooltip.debugger.step_mode.restart": "Mode: Restart", "hexdebug.tooltip.debugger.step_mode.stop": "Mode: Stop", "hexdebug.tooltip.focus_holder.item": "Item: %s", "hexdebug.tooltip.cognitohazard_iota": "Cognitohazard", "hexdebug.category.items.entry.debugging": "Debugging Items", "hexdebug.category.items.entry.debugging.page.debugger": "I have read vague descriptions of a strange object used by the ancients to help discover issues in complex _Hexes. I believe I have managed to reproduce this item; I call it the $(l:items/debugging#debugger)$(item)Debugger/$.$(br2)It seems to work in a similar way to $(l:items/hexcasting)$(item)Artifacts/$. However, I can also use it to cast a _Hex right from an item (like a $(l:items/focus)$(item)Focus/$) in my off-hand.$(br2)Unfortunately, the $(l:items/debugging#debugger)$(item)Debugger/$ is not very useful on its own; to get the most out of it, I will need to $(l:https://github.com/object-Object/HexDebug/wiki/Setting-up-VSCode-with-HexDebug)set up/$ some sort of $(l:https://marketplace.visualstudio.com/items?itemName=object-Object.hex-casting)external tool/$.", "hexdebug.category.items.entry.debugging.page.thwack": "$(italic)Thwack!/$$(br2)I can also switch between different \"step modes\" of the $(item)Debugger/$ by sneak-scrolling (like with a $(l:items/spellbook)$(item)Spellbook/$ or $(l:items/abacus)$(item)Abacus/$).", "hexdebug.category.items.entry.debugging.page.evaluator": "Complementing the $(l:items/debugging#debugger)$(item)Debugger/$, I've also created a new type of staff: the $(l:items/debugging#evaluator)$(item)Evaluator/$.$(br2)While debugging a _Hex, patterns drawn with this staff will be cast using the current stack and $(l:patterns/readwrite#hexcasting:local)$(thing)ravenmind/$ of the $(l:items/debugging#debugger)$(item)Debugger/$.$(br2)Clearing the grid seems to reset the $(l:items/debugging#debugger)$(item)Debugger/$ to just before the first pattern was drawn with the $(l:items/debugging#evaluator)$(item)Evaluator/$. It will not, of course, undo any effects performed by spells on the world.", "hexdebug.category.items.entry.debugging.page.thwonk": "$(italic)Thwonk!/$", "hexdebug.category.items.entry.focus_holder": "Focal Frame", "hexdebug.category.items.entry.focus_holder.page.1": "$(l:items/focus)$(item)Foci/$ are useful for storing _Hexes and other iotas in my inventory, but I sometimes find myself in need of a way to store iotas in the world. $(item)Item Frames/$ are too fragile, and $(l:greatwork/akashiclib)other methods/$ are inefficient and... distasteful. A cleaner solution is necessary, and I've devised one in the form of the $(item)Focal Frame/$.", "hexdebug.category.items.entry.focus_holder.page.2": "A $(item)Focal Frame/$ by itself is useless. An $(l:items/focus)iota-holding item/$ must first be inserted by right-clicking a placed $(item)Frame/$ with the item, or by using a single $(item)Frame/$ in my inventory in a manner akin to a $(item)Bundle/$. Right-clicking with an empty hand extracts the item.$(br2)As an item, I can use a filled $(item)Focal Frame/$ with any $(l:patterns/readwrite#hexcasting:read)patterns/$ or $(l:items/splicing_table)blocks/$ that would accept the contained item. When placed in the world, I can access it using patterns like $(l:patterns/readwrite_blocks#hexcasting:read/entity)$(action)Chronicler's Purification/$.", "hexdebug.category.items.entry.focus_holder.page.3": "$(italic)Two thousand movies, four thousand albums, music and words and pictures like voices whispering from a sweet, sunny past./$", "hexdebug.category.items.entry.splicing_table": "Splicing Table", "hexdebug.category.items.entry.splicing_table.page.1": "As my _Hexes become more complex, I find myself spending more and more time fixing my own mistakes. Patterns such as $(l:patterns/patterns_as_iotas#hexcasting:undo)$(action)Evanition/$ and $(l:patterns/lists#hexcasting:replace)$(action)Surgeon's Exaltation/$ can suffice for simple substitutions, but I think I can do better.$(br2)The $(l:items/splicing_table)$(item)Splicing Table/$ is my solution to these woes: a full-fledged workstation for viewing and editing _Hexes.", "hexdebug.category.items.entry.splicing_table.page.2": "To begin, I must place an item containing a list iota (eg. a $(l:items/focus)$(item)Focus/$) in the centre of the table. This reveals the first nine iotas in the list. The small arrows at the ends can be used to move my view of the list; I can also hold $(k:sneak) to move by a full page, or $(k:sprint) to move all the way to the start or end.$(br2)If I wish to share my _Hexes with others, I can use the large button on the right side to copy the contents of the list to my \"clipboard\".", "hexdebug.category.items.entry.splicing_table.page.3": "I can select iotas (or the space between them) by clicking on them. Holding $(k:sneak) and clicking again allows me to select a range of iotas.$(br2)Additionally, there are dedicated buttons to select the entire list ($(thing)Select All/$) and to clear my selection ($(thing)Select None/$).$(br2)Selecting iotas allows me to unlock the true power of the $(l:items/splicing_table)$(item)Splicing Table/$: editing _Hexes.", "hexdebug.category.items.entry.splicing_table.page.actions": "With $(l:items/splicing_table#cost)sufficient media/$, I can perform the following actions:$(li)$(thing)Nudge Left/$: Move the selected iota(s) one space to the left.$(li)$(thing)Nudge Right/$: Move the selected iota(s) one space to the right.$(li)$(thing)Delete/$: Remove the selected iota(s) from the list.$(li)$(thing)Duplicate/$: Create a copy of the selected iota(s).$(li)$(thing)Undo/$: Revert the last action performed.$(li)$(thing)Redo/$: Re-perform actions previously reverted with $(thing)Undo/$.", "hexdebug.category.items.entry.splicing_table.page.secondary": "For more advanced operations, some extra storage is required. I can place an iota-holding item in the slot to the left to unlock the following actions:$(li)$(thing)Copy/$: Write the selected iota(s) to a new list in the secondary item.$(li)$(thing)Cut/$: Same as $(thing)Copy/$, but also delete the selected iota(s).$(li)$(thing)Paste/$: Replace the selected iota(s) with the iota in the secondary item. If the iota is a list, its contents are pasted instead; I can override this by holding $(k:sneak).", "hexdebug.category.items.entry.splicing_table.page.staff": "Finally, I can insert a $(l:items/staff)$(item)Staff/$ into the lower left slot to reveal a miniature casting grid. Patterns drawn on this grid are inserted directly into the list, overwriting any selected iotas.$(br2)There are also six general-purpose inventory slots on the right side. These have no special functionality; they're just a convenient place to store a few extra items.", "hexdebug.category.items.entry.splicing_table.page.cost": "Unfortunately, all of this incredible versatility comes at a cost. In order to modify the contents of items, _media is required - about a tenth of one $(l:items/amethyst)$(item)Amethyst Dust/$ per action performed.$(br2)I can supply _media to the $(l:items/splicing_table)$(item)Splicing Table/$ by putting it in the lower right slot. The table will consume up to ten $(l:items/amethyst)$(item)Amethyst Dust/$ at once; any surplus is ignored until it can be consumed without wasting _media.", "hexdebug.category.items.entry.splicing_table.page.patterns": "If this small cost is prohibitive, or if I wish to perform more complicated actions than those previously described, there is another option. I can use patterns such as $(l:patterns/readwrite_blocks#hexcasting:read/entity)$(action)Chronicler's Purification/$ to manipulate the contents of the item in the main slot, and I've devised some $(l:patterns/splicing_table)specialized patterns/$ to control other aspects of the splicing table.$(br2)Now, if only I could make the table think for itself...", "hexdebug.category.items.entry.splicing_table.page.recipe": "$(italic)She plugged in strings one after the other, the tiny metal cubes flying in and out as her fingers danced over the tray with blinding speed./$", "hexdebug.category.greatwork.entry.enlightened_splicing_table": "Mindsplice Table", "hexdebug.category.greatwork.entry.enlightened_splicing_table.page.1": "The $(l:items/splicing_table)$(item)Splicing Table/$ is fine. Adequate. But limited, oh so limited. I have $(italic)seen/$ what is possible now, and I must have it, no matter the cost.$(br2)I shall MAKE the table think for itself.", "hexdebug.category.greatwork.entry.enlightened_splicing_table.page.2": "A solution. Yes. Familiar -- almost $(italic)simple/$ in its infinite complexity. As with my $(l:greatwork/impetus)previous insights/$, I can specialize a mind -- sever it from the body, redirect, connect, rewire, $(italic)transform/$ -- for the task at hand. Like an $(l:greatwork/impetus)$(item)Impetus/$... but greater, more complicated, more and more and more and more and-- I MUST FOCUS.", "hexdebug.category.greatwork.entry.enlightened_splicing_table.page.recipe": "Another $(l:greatwork/brainsweeping)$(thing)mindflaying/$ ritual. The task demanded of the mind is almost identical to that of a $(l:greatwork/impetus)$(item)Toolsmith Impetus/$, but more experience is required for this specialized, intricate work.", "hexdebug.category.greatwork.entry.enlightened_splicing_table.page.3": "The resulting $(thing)Mindsplice Table/$ is almost the same as before, but transmuted, $(italic)improved/$, in a single all-important way. With a mind to channel the patterns, the table can cast $(italic)any/$ _Hex almost effortlessly, triggered by nothing more than the press of a button.$(br)A small $(l:items/splicing_table#cost)infusion/$ of media is still required to initiate the process -- wasteful, but perhaps less so than my archaic, short-sighted designs of old. For spells, media is drawn from the same source.", "hexdebug.category.greatwork.entry.enlightened_splicing_table.page.4": "Of course, the flayed mind has limits. It must be $(italic)taught/$; even such a skilled mind cannot predict my needs without some guidance. Unlike an $(l:greatwork/impetus)$(item)Impetus/$, however, slates are not required -- the commands are instead $(l:patterns/enlightened_splicing_table)$(thing)imbued/$ directly into the mind, rewriting its neural pathways and leaving it no choice but to carry out my will.", "hexdebug.category.greatwork.entry.enlightened_splicing_table.page.5": "To facilitate even more complicated operations -- one $(thing)Mindsplice Table/$ controlling, $(italic)dominating/$, the next, and so on and so on and so on and so on and so on into eternity, if I have the patience and $(l:casting/mishaps)capacity/$ to use it -- the table's influence extends a small distance (four blocks, no more and no less) from the table. Small, yes, but perfectly adequate for most purposes. If more space is needed, my $(l:patterns/great_spells/greater_sentinel#hexcasting:sentinel/create/great)$(action)Greater Sentinel/$ can be used.", "hexdebug.category.greatwork.entry.quenching_debuggers": "Quenching Debuggers", "hexdebug.category.greatwork.entry.quenching_debuggers.page.1": "My mind has been apotheosized, but my $(l:items/debugging)tools/$ are still so $(italic)limited/$, bursting at the seams with the enormity of the Work. I need -- no, DESERVE -- more.$(br2)The shards of an Allay make an excellent medium for the task. As they twist and jump around, so too can these tools -- holding $(k:sneak) and $(k:sprint) while scrolling will switch between slots for _Hexes to debug.", "hexdebug.category.patterns.entry.debugging": "Debugging Patterns", "hexdebug.category.patterns.entry.debugging.page.const/debugging": "Add $(thing)True/$ to the top of the stack if executed by a $(l:items/debugging#debugger)$(item)Debugger/$ or $(l:items/debugging#evaluator)$(item)Evaluator/$, or $(thing)False/$ otherwise.", "hexdebug.category.patterns.entry.debugging.page.const/cognitohazard.1": "Add a $(thing)Cognitohazard/$ to the top of the stack.", "hexdebug.category.patterns.entry.debugging.page.const/cognitohazard.2": "It seems certain $(l:items/debugging#evaluator)debugging tools/$ may pose a security risk for some $(l:patterns/meta#hexcasting:eval/cc)high-level techniques/$. To help combat this, I have created this pattern.$(br2)When a $(thing)Cognitohazard/$ iota is executed normally, nothing happens. However, if one is present in a _Hex executed by a $(l:items/debugging#debugger)$(item)Debugger/$, it will cause the _Hex to terminate $(italic)immediately/$ - even before the $(thing)Cognitohazard/$ is actually executed.", "hexdebug.category.patterns.entry.debugging.page.breakpoint/before": "Pause the $(l:items/debugging#debugger)$(item)Debugger/$ before executing this pattern.", "hexdebug.category.patterns.entry.debugging.page.breakpoint/after": "Pause the $(l:items/debugging#debugger)$(item)Debugger/$ after executing this pattern (ie. before executing the next pattern).", "hexdebug.category.patterns.entry.debugging.page.craft/debugger": "Create a $(l:items/debugging#debugger)$(item)Debugger/$ that casts a _Hex, similar to $(l:patterns/spells/hexcasting)certain other patterns/$ I've used in the past.$(br2)Costs about ten $(l:items/amethyst)$(item)Charged Amethyst/$.", "hexdebug.category.patterns.entry.debugging.page.craft/quenched_debugger": "Create a $(l:greatwork/quenching_debuggers)$(item)Quenched Debugger/$ that casts a _Hex, similar to $(l:patterns/spells/hexcasting)certain other patterns/$ I've used in the past.$(br2)Costs about ten $(l:items/amethyst)$(item)Charged Amethyst/$.", "hexdebug.category.patterns.entry.splicing_table": "Splicing Table Patterns", "hexdebug.category.patterns.entry.splicing_table.page.view_index/read": "Remove a vector from the stack, then push the index of the leftmost iota currently visible in the $(l:items/splicing_table)$(item)Splicing Table/$ at that position.", "hexdebug.category.patterns.entry.splicing_table.page.view_index/write": "Remove a vector and number from the stack, then move the view of the $(l:items/splicing_table)$(item)Splicing Table/$ at that position so that the given index is the leftmost one visible.", "hexdebug.category.patterns.entry.splicing_table.page.selection/read.1": "Remove a vector from the stack, then push two values representing the current selection in the $(l:items/splicing_table)$(item)Splicing Table/$ at that position.", "hexdebug.category.patterns.entry.splicing_table.page.selection/read.2": "If a range of iotas is selected, two numbers are pushed, representing the start (inclusive) and end (exclusive) of the selected range. If the edge between two iotas is selected, the index of the iota to the right of the selected edge is pushed, followed by $(l:casting/influences)$(thing)Null/$. And if nothing is selected, $(l:casting/influences)$(thing)Null/$ is pushed twice.", "hexdebug.category.patterns.entry.splicing_table.page.selection/write": "Remove a vector and two values from the stack, then set the selection of the $(l:items/splicing_table)$(item)Splicing Table/$ at that position as previously described.", "hexdebug.category.patterns.entry.splicing_table.page.list/spellbook_index/read": "Remove a vector from the stack, then push the current page number (starting at 1) of the $(l:items/spellbook)$(item)Spellbook/$ in the main slot of the $(l:items/splicing_table)$(item)Splicing Table/$ or $(l:items/focus_holder)$(item)Focal Frame/$ at that position.", "hexdebug.category.patterns.entry.splicing_table.page.list/spellbook_index/write": "Remove a vector and number from the stack, then flip the $(l:items/spellbook)$(item)Spellbook/$ in the main slot of the $(l:items/splicing_table)$(item)Splicing Table/$ or $(l:items/focus_holder)$(item)Focal Frame/$ at that position to the given page number.", "hexdebug.category.patterns.entry.splicing_table.page.list/spellbook_index/readable": "Replace the vector at the top of the stack with $(thing)True/$ if there is a $(l:items/splicing_table)$(item)Splicing Table/$ or $(l:items/focus_holder)$(item)Focal Frame/$ at that position with a $(l:items/spellbook)$(item)Spellbook/$ in its main slot that contains at least one page, or $(thing)False/$ otherwise.", "hexdebug.category.patterns.entry.splicing_table.page.clipboard/read": "Remove a vector from the stack, then copy the contents of the secondary item in the $(l:items/splicing_table)$(item)Splicing Table/$ at that position and push it to the stack.", "hexdebug.category.patterns.entry.splicing_table.page.clipboard/write": "Remove a vector and iota from the stack, then save the iota into the secondary item in the $(l:items/splicing_table)$(item)Splicing Table/$ at that position.$(br)As with $(l:patterns/readwrite_blocks#hexcasting:write/entity)$(action)Chronicler's Gambit/$, I cannot write my own Name using this spell.", "hexdebug.category.patterns.entry.splicing_table.page.clipboard/readable": "Replace the vector at the top of the stack with $(thing)True/$ if there is a $(l:items/splicing_table)$(item)Splicing Table/$ at that position containing a secondary item that I could read, or $(thing)False/$ otherwise.", "hexdebug.category.patterns.entry.splicing_table.page.clipboard/writable": "Replace the vector at the top of the stack with $(thing)True/$ if there is a $(l:items/splicing_table)$(item)Splicing Table/$ at that position containing a secondary item that I could save an iota into, or $(thing)False/$ otherwise.", "hexdebug.category.patterns.entry.splicing_table.page.clipboard/spellbook_index/read": "Like $(l:patterns/splicing_table#hexdebug:splicing/list/spellbook_index/read)$(action)Projectionist's Purification/$, but the page number of the $(l:items/spellbook)$(item)Spellbook/$ in the secondary slot is read instead of the main slot.", "hexdebug.category.patterns.entry.splicing_table.page.clipboard/spellbook_index/write": "Like $(l:patterns/splicing_table#hexdebug:splicing/list/spellbook_index/write)$(action)Projectionist's Gambit/$, but the page number of the $(l:items/spellbook)$(item)Spellbook/$ in the secondary slot is written instead of the main slot.", "hexdebug.category.patterns.entry.splicing_table.page.clipboard/spellbook_index/readable": "Like $(l:patterns/splicing_table#hexdebug:splicing/list/spellbook_index/readable)$(action)Shutter's Purification/$, but the $(l:items/spellbook)$(item)Spellbook/$ in the secondary slot is checked instead of the main slot.", "hexdebug.category.patterns.entry.enlightened_splicing_table": "Mindsplice Table Patterns", "hexdebug.category.patterns.entry.enlightened_splicing_table.page.hex/read": "Remove a vector from the stack, then push the _Hex currently imbued to the $(l:greatwork/enlightened_splicing_table)$(item)Mindsplice Table/$ at that position, or $(l:casting/influences)$(thing)Null/$ if it has not yet been imbued.", "hexdebug.category.patterns.entry.enlightened_splicing_table.page.hex/write": "Remove a vector and list of patterns from the stack, then imbue the list of patterns into the $(l:greatwork/enlightened_splicing_table)$(item)Mindsplice Table/$ at that position.$(br)Costs about five $(l:items/amethyst)$(item)Charged Amethyst/$.", "hexdebug.category.patterns.entry.enlightened_splicing_table.page.circle": "In addition to these patterns, I can also cast $(l:patterns/circle#hexcasting:circle/impetus_pos)$(action)Waystone Reflection/$ and $(l:patterns/circle#hexcasting:circle/impetus_dir)$(action)Lodestone Reflection/$ from within a $(l:greatwork/enlightened_splicing_table)$(item)Mindsplice Table/$. However, trying to cast them through a $(l:items/staff)$(item)Staff/$, or trying to cast other $(l:greatwork/spellcircles)$(item)Spell Circle/$-only patterns through a $(l:greatwork/enlightened_splicing_table)$(item)Mindsplice Table/$, will still fail rather spectacularly."}