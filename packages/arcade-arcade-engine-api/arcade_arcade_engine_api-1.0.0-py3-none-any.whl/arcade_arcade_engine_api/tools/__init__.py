"""Arcade Starter Tools for Engine

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from enum import Enum
from typing import Annotated, Any

import httpx
import jsonschema
from arcade_tdk import ToolContext, tool
from arcade_tdk.errors import RetryableToolError

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any],
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            # Run validation to provide additional context
            is_valid, validation_error = validate_json_against_schema(request_data, schema)

            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            if not is_valid:
                # Schema validation found issues - additional context
                additional_context = (
                    f"{api_error_details}\n\n"
                    f"Schema validation found the following issues:\n"
                    f"{validation_error}"
                )
            else:
                # Schema validation passed - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_secrets=["ARCADE_API_KEY"])
async def list_available_auth_providers(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'auth-providers-list'."]:
    """Retrieve a list of available authentication providers.

    This tool fetches a paginated list of authentication providers accessible to the caller. It should be used when identifying or managing auth providers in the system."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/admin/auth_providers",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_auth_provider_details(
    context: ToolContext,
    auth_provider_id: Annotated[str, "The ID of the authentication provider to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'auth-providers-get'."]:
    """Retrieve details of a specific authentication provider.

    Use this tool to obtain the details of a particular authentication provider by specifying its ID."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/admin/auth_providers/{id}".format(id=auth_provider_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def delete_auth_provider(
    context: ToolContext,
    auth_provider_id: Annotated[str, "The ID of the authentication provider to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'auth-providers-delete'."]:
    """Delete a specific auth provider by ID.

    This tool deletes a specified authentication provider using its ID. It should be called when you need to remove an auth provider from the system."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/admin/auth_providers/{id}".format(id=auth_provider_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def delete_secret_by_id(
    context: ToolContext,
    secret_id: Annotated[str, "The unique identifier of the secret to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'secrets-delete'."]:
    """Deletes a secret using its unique ID.

    Use this tool to delete a specific secret identified by its ID. Useful when needing to permanently remove a secret from the system."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/admin/secrets/{secret_id}".format(secret_id=secret_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def update_session_verification_settings(
    context: ToolContext,
    unsafe_skip_verification: Annotated[
        bool | None, "Set to true to skip the session verification, making it unsafe."
    ] = None,
    verifier_url: Annotated[
        str | None,
        "The URL of the verifier service used for session verification. Provide a valid URL.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'session-verification-settings-update'."
]:
    """Update session verification settings for a user.

    This tool updates the session verification settings for the user or entity making the call. It should be used when there's a need to modify how sessions are verified, reflecting any new security or configuration preferences."""  # noqa: E501
    request_data = remove_none_values({
        "unsafe_skip_verification": unsafe_skip_verification,
        "verifier_url": verifier_url,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/admin/settings/session_verification",
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("ARCADE_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def list_auth_connections(
    context: ToolContext,
    page_offset: Annotated[
        int | None,
        "The starting point in the list for pagination. Useful for retrieving subsequent pages of data.",  # noqa: E501
    ] = None,
    page_size: Annotated[
        int | None,
        "Number of auth connections to return per page. Use to control the size of the result set.",
    ] = None,
    provider_id: Annotated[str | None, "Unique identifier for the authentication provider."] = None,
    user_id: Annotated[
        str | None, "The unique identifier for the user to list authentication connections for."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'auth-connections-list'."]:
    """Retrieve all authentication connections for users.

    Use this tool to get a comprehensive list of all authentication connections associated with users. Ideal for managing or auditing user authentication setups."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/admin/user_connections",
        method="GET",
        params=remove_none_values({
            "provider.id": provider_id,
            "user.id": user_id,
            "limit": page_size,
            "offset": page_offset,
        }),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def delete_user_auth_connection(
    context: ToolContext,
    connection_id: Annotated[
        str, "The unique identifier for the user/auth provider connection to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'auth-connections-delete'."]:
    """Deletes a user/auth provider connection.

    This tool deletes a connection between a user and an authentication provider. It should be called when a user needs to disconnect their account from an external auth provider."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/admin/user_connections/{id}".format(id=connection_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def check_auth_status(
    context: ToolContext,
    authorization_id: Annotated[
        str, "The unique ID for the authorization process to check its status."
    ],
    timeout_in_seconds: Annotated[
        int | None, "Specify the timeout duration in seconds. Maximum allowed is 59 seconds."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'auth-status'."]:
    """Verify the ongoing authorization status of a tool.

    Use this tool to check the status of an ongoing authorization process for a specific tool. Ideal for monitoring when an authorization completes or times out."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/auth/status",
        method="GET",
        params=remove_none_values({"id": authorization_id, "wait": timeout_in_seconds}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def retrieve_formatted_tools_list(
    context: ToolContext,
    filter_by_toolkit: Annotated[
        str | None, "Specify the toolkit name to filter the list of tools."
    ] = None,
    number_of_items_to_return: Annotated[
        int | None, "Specify the number of tools to return. Defaults to 25, with a maximum of 100."
    ] = None,
    offset_start_index: Annotated[
        int | None, "Offset from the start of the tools list. Default is 0."
    ] = None,
    provider_format: Annotated[
        str | None,
        "Format the tools according to the provider's specifications. Accepts a string value.",
    ] = None,
    user_identifier: Annotated[
        str | None, "The ID of the user for whom the tool list is to be retrieved."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tools-list-formatted'."]:
    """Fetches a formatted list of tools from engine configuration.

    Use this tool to retrieve a page of tools from the engine's configuration, which can be filtered by toolkit and formatted for a specific provider."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/formatted_tools",
        method="GET",
        params=remove_none_values({
            "toolkit": filter_by_toolkit,
            "limit": number_of_items_to_return,
            "offset": offset_start_index,
            "format": provider_format,
            "user_id": user_identifier,
        }),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_formatted_tool_specification(
    context: ToolContext,
    tool_name: Annotated[
        str, "The name of the tool for which the formatted specification is requested."
    ],
    provider_format: Annotated[
        str | None, "Specifies the format of the tool as required by the provider."
    ] = None,
    user_id: Annotated[
        str | None,
        "The identifier for the user requesting the tool specification. This should be a string.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tool-spec-formatted'."]:
    """Fetches a formatted specification for a given tool.

    Use this to obtain detailed, formatted specifications for a specific tool from a provider."""
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/formatted_tools/{name}".format(name=tool_name),  # noqa: UP032
        method="GET",
        params=remove_none_values({"format": provider_format, "user_id": user_id}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool()
async def check_arcade_engine_health(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'arcade-health'."]:
    """Check the health status of the Arcade Engine.

    Use this tool to verify if the Arcade Engine service is currently healthy and operational."""
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/health",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def delete_mcp_endpoint(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'mcp-endpoint'."]:
    """Delete the Model Context Protocol endpoint data.

    This tool deletes data at the Model Context Protocol (MCP) endpoint, which supports Streamable HTTP transport. Use it to remove existing configurations or data tied to this endpoint."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/mcp",
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def list_accessible_projects(
    context: ToolContext,
    bearer_token: Annotated[str, "A string containing the Bearer (JWT) token for authentication."],
    items_to_skip: Annotated[
        int | None, "The number of projects to skip before starting to collect the result set."
    ] = 0,
    maximum_items_to_return: Annotated[
        int | None, "Specifies the maximum number of projects to return. Must be an integer."
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'list-projects'."]:
    """Retrieve a list of accessible projects.

    This tool returns all projects that the caller has access to. It is useful for identifying projects available to a specific user or account."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/projects",
        method="GET",
        params=remove_none_values({"limit": maximum_items_to_return, "offset": items_to_skip}),
        headers=remove_none_values({
            "Authorization": bearer_token,
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_project_details(
    context: ToolContext,
    authorization_token: Annotated[
        str,
        "JWT token required for authentication. Should be provided in the format: 'Bearer <token>'.",  # noqa: E501
    ],
    project_id: Annotated[
        str,
        "The unique identifier for the project to retrieve details for. This should be a string matching the project's ID in the database.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-project'."]:
    """Retrieve detailed information about a specific project.

    This tool fetches and returns detailed information for a given project based on its ID. Use it when you need to access specific details about a project."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/projects/{project_id}".format(project_id=project_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": authorization_token,
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_scheduled_tool_executions(
    context: ToolContext,
    items_limit: Annotated[
        int | None, "The number of scheduled tool executions to return. Defaults to 25, max is 100."
    ] = None,
    list_offset: Annotated[
        int | None, "The starting position in the list of scheduled tool executions, default is 0."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tool-scheduled-list'."]:
    """Fetch a list of scheduled tool executions.

    Use this tool to retrieve a page of scheduled tool executions, useful for monitoring upcoming automated processes."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/scheduled_tools",
        method="GET",
        params=remove_none_values({"limit": items_limit, "offset": list_offset}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_scheduled_tool_details(
    context: ToolContext,
    scheduled_execution_id: Annotated[
        str, "The unique identifier for the scheduled tool execution to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tool-scheduled-get'."]:
    """Retrieve details for a specific scheduled tool execution.

    Use this tool to get information about a specific tool execution that has been scheduled, based on its unique identifier. It provides insights into the timing and parameters of the execution."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/scheduled_tools/{id}".format(id=scheduled_execution_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool()
async def get_openapi_specification(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'openapi' (returns OpenAPI 3.0 specification)."
]:
    """Get the OpenAPI 3.0 specification in JSON format.

    Use this tool to retrieve the OpenAPI 3.0 specification for the Arcade Engine API, which provides detailed information about all available endpoints and their usage."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/openapi",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_tools_list(
    context: ToolContext,
    include_formats: Annotated[
        list[str] | None,
        "List of tool formats to include in the response, specified by their names.",
    ] = None,
    items_per_page: Annotated[
        int | None,
        "Specify the number of tools to return, with a maximum of 100. Defaults to 25 if not specified.",  # noqa: E501
    ] = None,
    start_offset: Annotated[
        int | None, "Offset to determine the starting point from the list of tools. Default is 0."
    ] = None,
    toolkit_name: Annotated[
        str | None, "Specifies the name of the toolkit to filter the tools list."
    ] = None,
    user_id: Annotated[
        str | None,
        "The ID of the user requesting the tool list. It is used to filter the results for a specific user context.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tools-list-static'."]:
    """Retrieve a list of tools from the engine configuration.

    Use this tool to get a paginated list of tools available in the engine configuration, with optional filtering by toolkit."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/tools",
        method="GET",
        params=remove_none_values({
            "toolkit": toolkit_name,
            "limit": items_per_page,
            "offset": start_offset,
            "include_format": include_formats,
            "user_id": user_id,
        }),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def authorize_user_tool_access(
    context: ToolContext,
    tool_name_for_authorization: Annotated[
        str, "Specify the name of the tool to authorize the user for access."
    ],
    redirect_uri_after_authorization: Annotated[
        str | None, "Optional URI to redirect the user after authorization."
    ] = None,
    tool_version: Annotated[
        str | None,
        "Specify the tool version to authorize. If not provided, any version will be used.",
    ] = None,
    user_id: Annotated[
        str | None,
        "The unique identifier for a user. Required only when using an API key for authorization.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tool-authorize'."]:
    """Authorize a user to access a specific tool.

    This tool authorizes a user for a specific tool by its name. It should be called when a user needs permission to access a specific tool. The tool returns the authorization status."""  # noqa: E501
    request_data = remove_none_values({
        "next_uri": redirect_uri_after_authorization,
        "tool_name": tool_name_for_authorization,
        "tool_version": tool_version,
        "user_id": user_id,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/tools/authorize",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("ARCADE_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def execute_tool(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tool-execute'."]:
    """Execute a specified tool with given parameters.

    This tool allows the execution of a specified tool by providing its name and necessary arguments. It's useful for triggering specific actions or processes as dictated by the tool's logic.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["EXECUTETOOL"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["EXECUTETOOL"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["EXECUTETOOL"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.arcade.dev/v1/tools/execute",
        method="POST",
        request_data=request_data,
        schema=json.loads(REQUEST_BODY_SCHEMAS["EXECUTETOOL"]),
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("ARCADE_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_tool_specification(
    context: ToolContext,
    tool_name: Annotated[
        str,
        "The name of the tool whose specification is to be retrieved. This should match the tool's registered name.",  # noqa: E501
    ],
    formats_to_include: Annotated[
        list[str] | None,
        "List of tool formats to include in the response. Provide formats as a list of strings.",
    ] = None,
    user_identifier: Annotated[
        str | None, "The unique identifier for the user requesting the tool specification."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tool-spec'."]:
    """Retrieve the specification for a specific arcade tool.

    This tool returns the arcade tool specification for a specified tool by its name. It should be called when there's a need to understand the details or capabilities of a particular tool."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/tools/{name}".format(name=tool_name),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "include_format": formats_to_include,
            "user_id": user_identifier,
        }),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def list_workers(
    context: ToolContext,
    number_of_items_to_return: Annotated[
        int | None,
        "The maximum number of worker items to return, with a default of 25 and a maximum of 100.",
    ] = None,
    start_offset: Annotated[
        int | None, "Offset from the start of the list for pagination. Defaults to 0."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'workers-list'."]:
    """Retrieve a list of all workers with their definitions.

    Use this tool to get information about all available workers and their definitions. This can be helpful for managing or reviewing the current worker pool."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/workers",
        method="GET",
        params=remove_none_values({"limit": number_of_items_to_return, "offset": start_offset}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def create_worker(
    context: ToolContext,
    worker_id: Annotated[
        str, "A unique identifier for the worker to be created. It should be a string."
    ],
    enable_worker: Annotated[
        bool | None,
        "Set to true to enable the new worker upon creation, or false to keep it disabled.",
    ] = None,
    http_retry_attempts: Annotated[
        int | None, "Number of retry attempts for HTTP requests if a failure occurs."
    ] = None,
    http_secret_key: Annotated[
        str | None,
        "A secret key used for HTTP authentication and authorization. It should be a secure string provided by the service.",  # noqa: E501
    ] = None,
    http_timeout_seconds: Annotated[
        int | None,
        "The timeout duration for the HTTP connection, specified in seconds. This defines how long the system should wait for the HTTP request to complete before timing out.",  # noqa: E501
    ] = None,
    mcp_retry_attempts: Annotated[
        int | None,
        "Specifies the number of retry attempts for MCP connections. Provide an integer value to define how many times the system should retry a connection if it fails.",  # noqa: E501
    ] = None,
    mcp_timeout_duration: Annotated[
        int | None, "The timeout duration for MCP operations in seconds. Must be an integer value."
    ] = None,
    worker_http_uri: Annotated[
        str | None,
        "The HTTP URI for the worker's endpoint. This expects a valid URL string that specifies where the worker's service can be accessed.",  # noqa: E501
    ] = None,
    worker_resource_uri: Annotated[
        str | None,
        "The URI for the worker's resource location or service endpoint. Provide the full URI as a string.",  # noqa: E501
    ] = None,
    worker_type: Annotated[
        str | None,
        "Specifies the type of worker to be created. It should be a string indicating the category or role of the worker.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'workers-create'."]:
    """Create a new worker in the system.

    This tool is used to add a new worker to the system. It should be called when there's a need to register a new worker."""  # noqa: E501
    request_data = remove_none_values({
        "enabled": enable_worker,
        "http": {
            "retry": http_retry_attempts,
            "secret": http_secret_key,
            "timeout": http_timeout_seconds,
            "uri": worker_http_uri,
        },
        "id": worker_id,
        "mcp": {
            "retry": mcp_retry_attempts,
            "timeout": mcp_timeout_duration,
            "uri": worker_resource_uri,
        },
        "type": worker_type,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/workers",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("ARCADE_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def test_worker_connection(
    context: ToolContext,
    worker_connection_type: Annotated[
        str,
        "Specify the type of worker connection to test. It must be a string value indicating the category or mode of the worker.",  # noqa: E501
    ],
    http_uri: Annotated[
        str | None, "Specify the HTTP URI of the worker to test the connection."
    ] = None,
    mcp_uri: Annotated[
        str | None, "The URI for the MCP connection required to test a worker connection."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'workers-test'."]:
    """Test a worker connection before adding it to the system.

    Use this tool to verify if a worker connection is functioning properly before integrating it into your system."""  # noqa: E501
    request_data = remove_none_values({
        "http": {"uri": http_uri},
        "mcp": {"uri": mcp_uri},
        "type": worker_connection_type,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/workers/test",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("ARCADE_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_worker_by_id(
    context: ToolContext,
    worker_id: Annotated[str, "The unique identifier for the worker to retrieve details."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'workers-get'."]:
    """Retrieve worker details using their ID.

    Use this tool to obtain detailed information about a worker by providing their unique ID. Ideal for situations where specific worker data is required."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/workers/{id}".format(id=worker_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def delete_worker(
    context: ToolContext,
    worker_id: Annotated[str, "The unique identifier for the worker to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'workers-delete'."]:
    """Deletes a specified worker from the system.

    Use this tool to remove a worker by providing their unique ID. It should be called when you need to permanently delete a worker record from the system."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/workers/{id}".format(id=worker_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def authorize_worker(
    context: ToolContext,
    worker_id: Annotated[str, "The unique identifier for the worker to be authorized."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'workers-authorize'."]:
    """Authorize a worker based on their ID.

    This tool is used to verify and authorize a worker by their ID. It should be called when it's necessary to check if a worker has the appropriate permissions or status to perform certain tasks."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/workers/{id}/authorize".format(id=worker_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def get_worker_health_status(
    context: ToolContext,
    worker_id: Annotated[
        str, "The unique identifier for the worker whose health status you want to check."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'workers-health'."]:
    """Retrieve the health status of a worker.

    This tool is used to check the health status of a specific worker by their ID. It should be called when you need to monitor or verify the operational status of a worker."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/workers/{id}/health".format(id=worker_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ARCADE_API_KEY"])
async def fetch_tools_page(
    context: ToolContext,
    worker_id: Annotated[str, "The unique ID of the worker for which to retrieve the tools list."],
    number_of_items: Annotated[
        int | None,
        "Number of items to return in the result set. Default is 25 and the maximum is 100.",
    ] = None,
    start_offset: Annotated[
        int | None, "Offset from the start of the list for pagination. Defaults to 0."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tools-list'."]:
    """Retrieve a list of tools for a specific worker.

    This tool is used to get a list of tools associated with a specific worker ID. It should be called when you need an overview of tools for a particular worker."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.arcade.dev/v1/workers/{id}/tools".format(id=worker_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"limit": number_of_items, "offset": start_offset}),
        headers=remove_none_values({"Authorization": context.get_secret("ARCADE_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
