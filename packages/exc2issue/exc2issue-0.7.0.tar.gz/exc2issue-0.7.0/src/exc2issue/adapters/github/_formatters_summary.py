"""Summary and header formatting functions.

This module contains functions for generating headers, summaries, and the main
consolidated issue body composition.
"""

from typing import TYPE_CHECKING

from ._formatters_timeline import add_error_timeline

if TYPE_CHECKING:
    from exc2issue.core.error_collection import ErrorCollection, ErrorEntry


def generate_header(error_collection: "ErrorCollection") -> list[str]:
    """Generate header section for consolidated issue.

    Args:
        error_collection: Collection containing error information

    Returns:
        List of formatted header lines
    """
    return [
        f"# Consolidated Error Report: {error_collection.function_name}",
        "",
        f"**Function:** `{error_collection.function_name}`",
        f"**Execution Time:** {error_collection.start_time.isoformat()}",
        f"**Total Issues Detected:** {error_collection.get_error_count()}",
        "",
    ]


def add_function_context(
    body_parts: list[str], error_collection: "ErrorCollection"
) -> None:
    """Add function context section if arguments are available.

    Args:
        body_parts: List to append context sections to
        error_collection: Collection containing function context
    """
    if not (error_collection.function_args or error_collection.function_kwargs):
        return

    body_parts.extend(["## Function Context", ""])

    if error_collection.function_args:
        args_str = ", ".join(repr(arg) for arg in error_collection.function_args)
        body_parts.append(f"**Arguments:** `({args_str})`")

    if error_collection.function_kwargs:
        kwargs_str = ", ".join(
            f"{k}={repr(v)}" for k, v in error_collection.function_kwargs.items()
        )
        body_parts.append(f"**Keyword Arguments:** `{{{kwargs_str}}}`")

    body_parts.append("")


def add_error_summary(body_parts: list[str], error_collection: "ErrorCollection") -> None:
    """Add error summary by type section.

    Args:
        body_parts: List to append summary sections to
        error_collection: Collection containing errors to summarize
    """
    error_types = error_collection.get_errors_by_type()

    if not (error_types["exception"] or error_types["log"]):
        return

    body_parts.extend(["## Summary by Type", ""])

    if error_types["exception"]:
        add_exception_summary(body_parts, error_types["exception"])

    if error_types["log"]:
        add_log_summary(body_parts, error_types["log"])


def add_exception_summary(body_parts: list[str], exceptions: list["ErrorEntry"]) -> None:
    """Add exception summary to body.

    Args:
        body_parts: List to append exception summary to
        exceptions: List of exception error entries
    """
    body_parts.append(f"**Exceptions:** {len(exceptions)}")
    exception_summary: dict[str, int] = {}
    for error in exceptions:
        exc_type = error.error_record.error_type
        exception_summary[exc_type] = exception_summary.get(exc_type, 0) + 1
    for exc_type, count in exception_summary.items():
        body_parts.append(f"  - {exc_type}: {count}")
    body_parts.append("")


def add_log_summary(body_parts: list[str], logs: list["ErrorEntry"]) -> None:
    """Add log summary to body.

    Args:
        body_parts: List to append log summary to
        logs: List of log error entries
    """
    body_parts.append(f"**Log Errors:** {len(logs)}")
    log_summary: dict[str, int] = {}
    for error in logs:
        log_level = error.source_info.get("log_level", "ERROR")
        log_summary[log_level] = log_summary.get(log_level, 0) + 1
    for log_level, count in log_summary.items():
        body_parts.append(f"  - {log_level}: {count}")
    body_parts.append("")


def generate_consolidated_issue_body(
    error_collection: "ErrorCollection", gemini_description: str | None = None
) -> str:
    """Generate comprehensive issue body from error collection.

    Args:
        error_collection: Collection of errors from function execution
        gemini_description: Optional AI-generated description

    Returns:
        Formatted markdown body for the GitHub issue
    """
    body_parts = generate_header(error_collection)

    # Add function context if available
    add_function_context(body_parts, error_collection)

    # Add AI-generated description if available
    if gemini_description:
        body_parts.extend(["## AI Analysis", "", gemini_description, ""])

    # Add chronological error timeline
    add_error_timeline(body_parts, error_collection)

    # Add summary by error type
    add_error_summary(body_parts, error_collection)

    # Add footer
    body_parts.extend(
        [
            "---",
            "*This consolidated issue was automatically generated by "
            "[exc2issue](https://github.com/exc2issue/exc2issue)*",
        ]
    )

    return "\n".join(body_parts)
