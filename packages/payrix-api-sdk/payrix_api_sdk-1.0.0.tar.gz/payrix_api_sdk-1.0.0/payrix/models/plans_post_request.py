# -*- coding: utf-8 -*-

"""
payrix

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from payrix.api_helper import APIHelper
from payrix.models.plan_schedule_enum import PlanScheduleEnum
from payrix.models.subscriptions_post_request import SubscriptionsPostRequest


class PlansPostRequest(object):

    """Implementation of the 'plansPostRequest' model.

    Attributes:
        amount (int): The amount to charge with each payment under this Plan,
            specified as an integer in cents.
        billing (str): The attached billing for which recurring payments
            should be made to pay off statements.
        order (str): The order of the Txn that will be created through this
            Plan.
        txn_description (str): The description of the Txn that will be created
            through this Plan.
        description (str): A description of this Plan. This field is stored as
            a text string and must be between 0 and 100 characters long.
        max_failures (int): The maximum consecutive amount of payment failures
            to allow for a subscription before inactivating it.
        merchant (str): The identifier of the Merchant associated with this
            Plan.
        name (str): The name of this Plan. This field is stored as a text
            string and must be between 0 and 100 characters long.
        schedule (PlanScheduleEnum): The schedule that determines when the
            subscription related to this Plan is triggered.  <details>
            <summary>Valid Values</summary>  - `1` - **Daily** - `2` -
            **Weekly** - `3` - **Monthly** - `4` - **Annually**  </details>
        schedule_factor (int): A multiplier that you can use to adjust the
            schedule set in the 'schedule' field, such as daily, weekly,
            monthly, or annually. In this field is specified as an integer and
            its value determines how the interval is multiplied.
        um (PlanUmEnum): The unit of measure for the amount on the plan. 
            <details> <summary>Valid Values</summary>  - `actual` - **An
            actual amount to charge, in cents.** - `percent` - **A percentage
            of another amount, in basis points.**  </details>
        mtype (PlanTypeEnum): The type of plan.  <details> <summary>Valid
            Values</summary>  - `recurring` - **A recurring payment plan
            (subcription).**  - `installment`  - **A deferred payment
            installment plan.**   </details>
        inactive (InactiveEnum): Whether this resource is marked as inactive. 
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen. 
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>
        subscriptions (List[SubscriptionsPostRequest]): The model property of
            type List[SubscriptionsPostRequest].

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "amount": 'amount',
        "merchant": 'merchant',
        "schedule": 'schedule',
        "billing": 'billing',
        "order": 'order',
        "txn_description": 'txnDescription',
        "description": 'description',
        "max_failures": 'maxFailures',
        "name": 'name',
        "schedule_factor": 'scheduleFactor',
        "um": 'um',
        "mtype": 'type',
        "inactive": 'inactive',
        "frozen": 'frozen',
        "subscriptions": 'subscriptions'
    }

    _optionals = [
        'billing',
        'order',
        'txn_description',
        'description',
        'max_failures',
        'name',
        'schedule_factor',
        'um',
        'mtype',
        'inactive',
        'frozen',
        'subscriptions',
    ]

    def __init__(self,
                 amount=None,
                 merchant=None,
                 schedule=None,
                 billing=APIHelper.SKIP,
                 order=APIHelper.SKIP,
                 txn_description=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 max_failures=APIHelper.SKIP,
                 name=APIHelper.SKIP,
                 schedule_factor=0,
                 um='actual',
                 mtype='recurring',
                 inactive=0,
                 frozen=0,
                 subscriptions=APIHelper.SKIP):
        """Constructor for the PlansPostRequest class"""

        # Initialize members of the class
        self.amount = amount 
        if billing is not APIHelper.SKIP:
            self.billing = billing 
        if order is not APIHelper.SKIP:
            self.order = order 
        if txn_description is not APIHelper.SKIP:
            self.txn_description = txn_description 
        if description is not APIHelper.SKIP:
            self.description = description 
        if max_failures is not APIHelper.SKIP:
            self.max_failures = max_failures 
        self.merchant = merchant 
        if name is not APIHelper.SKIP:
            self.name = name 
        self.schedule = schedule 
        self.schedule_factor = schedule_factor 
        self.um = um 
        self.mtype = mtype 
        self.inactive = inactive 
        self.frozen = frozen 
        if subscriptions is not APIHelper.SKIP:
            self.subscriptions = subscriptions 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        amount = dictionary.get("amount") if dictionary.get("amount") else None
        merchant = dictionary.get("merchant") if dictionary.get("merchant") else None
        schedule = dictionary.get("schedule") if dictionary.get("schedule") else None
        billing = dictionary.get("billing") if dictionary.get("billing") else APIHelper.SKIP
        order = dictionary.get("order") if dictionary.get("order") else APIHelper.SKIP
        txn_description = dictionary.get("txnDescription") if dictionary.get("txnDescription") else APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        max_failures = dictionary.get("maxFailures") if dictionary.get("maxFailures") else APIHelper.SKIP
        name = dictionary.get("name") if dictionary.get("name") else APIHelper.SKIP
        schedule_factor = dictionary.get("scheduleFactor") if dictionary.get("scheduleFactor") else 0
        um = dictionary.get("um") if dictionary.get("um") else 'actual'
        mtype = dictionary.get("type") if dictionary.get("type") else 'recurring'
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        subscriptions = None
        if dictionary.get('subscriptions') is not None:
            subscriptions = [SubscriptionsPostRequest.from_dictionary(x) for x in dictionary.get('subscriptions')]
        else:
            subscriptions = APIHelper.SKIP
        # Return an object of this model
        return cls(amount,
                   merchant,
                   schedule,
                   billing,
                   order,
                   txn_description,
                   description,
                   max_failures,
                   name,
                   schedule_factor,
                   um,
                   mtype,
                   inactive,
                   frozen,
                   subscriptions)

    @classmethod
    def validate(cls, dictionary):
        """Validates dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """

        if isinstance(dictionary, cls):
            return APIHelper.is_valid_type(value=dictionary.amount,
                                           type_callable=lambda value: isinstance(value, int)) \
                and APIHelper.is_valid_type(value=dictionary.merchant,
                                            type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(value=dictionary.schedule,
                                            type_callable=lambda value: PlanScheduleEnum.validate(value))

        if not isinstance(dictionary, dict):
            return False

        return APIHelper.is_valid_type(value=dictionary.get('amount'),
                                       type_callable=lambda value: isinstance(value, int)) \
            and APIHelper.is_valid_type(value=dictionary.get('merchant'),
                                        type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(value=dictionary.get('schedule'),
                                        type_callable=lambda value: PlanScheduleEnum.validate(value))

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'amount={self.amount!r}, '
                f'billing={(self.billing if hasattr(self, "billing") else None)!r}, '
                f'order={(self.order if hasattr(self, "order") else None)!r}, '
                f'txn_description={(self.txn_description if hasattr(self, "txn_description") else None)!r}, '
                f'description={(self.description if hasattr(self, "description") else None)!r}, '
                f'max_failures={(self.max_failures if hasattr(self, "max_failures") else None)!r}, '
                f'merchant={self.merchant!r}, '
                f'name={(self.name if hasattr(self, "name") else None)!r}, '
                f'schedule={self.schedule!r}, '
                f'schedule_factor={(self.schedule_factor if hasattr(self, "schedule_factor") else None)!r}, '
                f'um={(self.um if hasattr(self, "um") else None)!r}, '
                f'mtype={(self.mtype if hasattr(self, "mtype") else None)!r}, '
                f'inactive={(self.inactive if hasattr(self, "inactive") else None)!r}, '
                f'frozen={(self.frozen if hasattr(self, "frozen") else None)!r}, '
                f'subscriptions={(self.subscriptions if hasattr(self, "subscriptions") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'amount={self.amount!s}, '
                f'billing={(self.billing if hasattr(self, "billing") else None)!s}, '
                f'order={(self.order if hasattr(self, "order") else None)!s}, '
                f'txn_description={(self.txn_description if hasattr(self, "txn_description") else None)!s}, '
                f'description={(self.description if hasattr(self, "description") else None)!s}, '
                f'max_failures={(self.max_failures if hasattr(self, "max_failures") else None)!s}, '
                f'merchant={self.merchant!s}, '
                f'name={(self.name if hasattr(self, "name") else None)!s}, '
                f'schedule={self.schedule!s}, '
                f'schedule_factor={(self.schedule_factor if hasattr(self, "schedule_factor") else None)!s}, '
                f'um={(self.um if hasattr(self, "um") else None)!s}, '
                f'mtype={(self.mtype if hasattr(self, "mtype") else None)!s}, '
                f'inactive={(self.inactive if hasattr(self, "inactive") else None)!s}, '
                f'frozen={(self.frozen if hasattr(self, "frozen") else None)!s}, '
                f'subscriptions={(self.subscriptions if hasattr(self, "subscriptions") else None)!s})')
