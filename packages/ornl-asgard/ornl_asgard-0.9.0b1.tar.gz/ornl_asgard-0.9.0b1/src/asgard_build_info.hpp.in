#pragma once

#define ASGARD_VERSION_MAJOR @asgard_VERSION_MAJOR@
#define ASGARD_VERSION_MINOR @asgard_VERSION_MINOR@
#define ASGARD_VERSION_PATCH @asgard_VERSION_PATCH@
#define ASGARD_VERSION "@asgard_VERSION@"

#cmakedefine ASGARD_USING_MKL
#cmakedefine ASGARD_USING_APPLEBLAS

#cmakedefine ASGARD_HAS_GITINFO
#define ASGARD_GIT_BRANCH "@ASGARD_GIT_BRANCH@"
#define ASGARD_GIT_COMMIT_HASH "@ASGARD_GIT_COMMIT_HASH@"
#define ASGARD_GIT_COMMIT_SUMMARY "@ASGARD_GIT_COMMIT_SUMMARY@"
#define ASGARD_RELEASE_INFO "@ASGARD_RELEASE_INFO@"

#cmakedefine ASGARD_USE_HIGHFIVE
#cmakedefine ASGARD_USE_TIMER
#cmakedefine ASGARD_USE_FLOPCOUNTER
#cmakedefine ASGARD_USE_OPENMP
#cmakedefine ASGARD_USE_CUDA
#cmakedefine ASGARD_USE_ROCM
#cmakedefine ASGARD_GPU_MEMGREEDY
#cmakedefine ASGARD_USE_MPI
#cmakedefine ASGARD_ENABLE_FLOAT
#cmakedefine ASGARD_ENABLE_DOUBLE

#define ASGARD_MAX_NUM_GPUS @ASGARD_MAX_NUM_GPUS@

#define ASGARD_NUM_GPU_BLOCKS @ASGARD_NUM_GPU_BLOCKS@
#define ASGARD_NUM_GPU_THREADS @ASGARD_NUM_GPU_THREADS@

#define ASGARD_NUM_QUADRATURE @ASGARD_NUM_QUADRATURE@

// enable arch agnostic GPU capabilities
#ifdef ASGARD_USE_CUDA
#define ASGARD_USE_GPU
#endif
#ifdef ASGARD_USE_ROCM
#define ASGARD_USE_GPU
#endif

#ifdef ASGARD_USE_GPU
#ifndef ASGARD_GPU_MEMGREEDY
#define ASGARD_GPU_NON_GREEDY
#endif
#endif

#if defined(ASGARD_USE_MPI) || defined(ASGARD_USE_GPU)
#define ASGARD_MANAGED_RESOURCES
#endif

// fixed variables, maybe adjust later using CMake
// for now, we can keep project-wide constants here
namespace asgard
{
/*!
 * Small scratch-space arrays are needed in many places in the code,
 * it is better to allocate those as std::array, thus avoid runtime
 * allocation and the heap altogether.
 * However, we need to know the size which is unknown until runtime.
 * This is a workaround that lets us have a max size.
 */
inline constexpr int max_num_dimensions = 6;

inline constexpr int max_num_gpus = ASGARD_MAX_NUM_GPUS;

#ifdef ASGARD_USE_MPI
/*!
 * Tuning parameters for the MPI algorithms, number of MPI ranks
 * that determines whether to use point-to-point (Send/Recv/Irecv)
 * or collective algorithms (Bcast, Reduce).
 * Those are system dependent, keep at 2 or 4 for easier testing, i.e.,
 * must use at least that many ranks to test the algorithms,
 * but modify during production. Can be set in CMake.
 */
namespace mpi {
inline constexpr int bcast_threshold  = @ASGARD_MPI_BCAST_THRESHOLD@;
inline constexpr int reduce_threshold = @ASGARD_MPI_REDUCE_THRESHOLD@;
}
#endif
}
