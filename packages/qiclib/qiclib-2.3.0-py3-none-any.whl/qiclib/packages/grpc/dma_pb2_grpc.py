# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

import qiclib.packages.grpc.datatypes_pb2 as datatypes__pb2
import qiclib.packages.grpc.dma_pb2 as dma__pb2

GRPC_GENERATED_VERSION = '1.73.1'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in dma_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class DMAServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Snapshot = channel.unary_stream(
                '/dma.DMAService/Snapshot',
                request_serializer=dma__pb2.StreamRequest.SerializeToString,
                response_deserializer=dma__pb2.AcquiredData.FromString,
                _registered_method=True)
        self.Snapshot32 = channel.unary_stream(
                '/dma.DMAService/Snapshot32',
                request_serializer=dma__pb2.StreamRequest.SerializeToString,
                response_deserializer=dma__pb2.AcquiredData.FromString,
                _registered_method=True)
        self.StreamContinuous = channel.unary_stream(
                '/dma.DMAService/StreamContinuous',
                request_serializer=dma__pb2.StreamRequest.SerializeToString,
                response_deserializer=dma__pb2.AcquiredData.FromString,
                _registered_method=True)
        self.GetPackageLossInfo = channel.unary_unary(
                '/dma.DMAService/GetPackageLossInfo',
                request_serializer=datatypes__pb2.Empty.SerializeToString,
                response_deserializer=dma__pb2.PackageLossInfo.FromString,
                _registered_method=True)
        self.FileStreamContinuous = channel.unary_unary(
                '/dma.DMAService/FileStreamContinuous',
                request_serializer=dma__pb2.FileWriteCommand.SerializeToString,
                response_deserializer=dma__pb2.PackageLossInfo.FromString,
                _registered_method=True)
        self.FileSnapshot = channel.unary_unary(
                '/dma.DMAService/FileSnapshot',
                request_serializer=dma__pb2.FileWriteCommand.SerializeToString,
                response_deserializer=dma__pb2.PackageLossInfo.FromString,
                _registered_method=True)
        self.FileSnapshot32 = channel.unary_unary(
                '/dma.DMAService/FileSnapshot32',
                request_serializer=dma__pb2.FileWriteCommand.SerializeToString,
                response_deserializer=dma__pb2.PackageLossInfo.FromString,
                _registered_method=True)
        self.FileDownload = channel.unary_stream(
                '/dma.DMAService/FileDownload',
                request_serializer=dma__pb2.FileRequest.SerializeToString,
                response_deserializer=dma__pb2.FileContent.FromString,
                _registered_method=True)


class DMAServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def Snapshot(self, request, context):
        """*
        @brief request a limited stream of 8-bit data

        Will start data acquisition for a given amount of 8-bit samples. 
        If multiple channels are transmitted in time domain multiplex,
        individual channels can be selected by the channels parameter. \n 
        An empty list will select all channels.
        Note that this will affect the data rate. Operating at low data rates
        a timeout needs to be set (see @link StreamRequest @endlink).

        @param msg Combination of sample count, channel list and timeout in ms.
        @returns stream of acquired data.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Snapshot32(self, request, context):
        """*
        @brief request a limited stream of 32-bit data

        Will start data acquisition for a given amount of 32-bit samples. 
        If multiple channels are transmitted in time domain multiplex,
        individual channels can be selected by the channels parameter. 
        An empty list will select all channels.
        Note that this will affect the data rate. Operating at low data rates
        a timeout needs to be set (see @link StreamRequest @endlink).

        @param msg Combination of sample count, channel list and timeout in ms.
        @returns stream of acquired data.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamContinuous(self, request, context):
        """*
        @brief request unlimited 32-bit datastream

        Will start data acquisition for a given amount of 8-bit samples. 
        If multiple channels are transmitted in time domain multiplex,
        individual channels can be selected by the channels parameter. \n 
        An empty list will select all channels.
        Note that this will affect the data rate. Operating at low data rates
        a timeout needs to be set (see @link StreamRequest @endlink).
        Stop acquisiton by calling cancel on the stream reply from the server.

        @param msg Combination of channel list and timeout in ms.
        @returns stream of acquired data.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetPackageLossInfo(self, request, context):
        """*
        @brief Get Package Loss info of latest stream request.

        For the acquisition the data stream is buffered in a FIFO on hardware level.
        If writing the data into the FIFO does not succeed (e.g. if the FIFO is full)
        the data is lost. 

        Software loss occurrs, if user does not fetch data quick enough. 
        The buffer in kernel space will overflow.

        @returns Combination of bytes lost in hardware and bytes lost in software.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def FileStreamContinuous(self, request, context):
        """*
        @brief request unlimited 32-bit datastream to file

        Will start data acquisition for a given amount of 8-bit samples. 
        If multiple channels are transmitted in time domain multiplex,
        individual channels can be selected by the channels parameter. 
        An empty list will select all channels.
        Note that this will affect the data rate. Operating at low data rates
        a timeout needs to be set (see @link StreamRequest @endlink).
        TODO: How to stop Acquisition?

        The name and subdirectory for the data file can be set.
        The disk type parameter passed must match the device mounted 
        into the directory set in servicehub_conf.json

        @param msg Combination of file name, subdirectory, disk type and @link StreamRequest @endlink
        @returns data loss in hardware and software, see @link GetPackageLossInfo @endlink
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def FileSnapshot(self, request, context):
        """*
        @brief request a limited stream of 8-bit data to file

        Will start data acquisition for a given amount of 32-bit samples. 
        If multiple channels are transmitted in time domain multiplex,
        individual channels can be selected by the channels parameter. \n
        An empty list will select all channels.
        Note that this will affect the data rate. Operating at low data rates
        a timeout needs to be set (see @link StreamRequest @endlink).

        @param msg Combination of file name, subdirectory, disk type and @link StreamRequest @endlink
        @returns data loss in hardware and software, see @link GetPackageLossInfo @endlink
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def FileSnapshot32(self, request, context):
        """*
        @brief request a limited stream of 32-bit data to file

        Will start data acquisition for a given amount of 32-bit samples. 
        If multiple channels are transmitted in time domain multiplex,
        individual channels can be selected by the channels parameter. \n
        An empty list will select all channels.
        Note that this will affect the data rate. Operating at low data rates
        a timeout needs to be set (see @link StreamRequest @endlink).

        @param msg Combination of file name, subdirectory, disk type and @link StreamRequest @endlink
        @returns data loss in hardware and software, see @link GetPackageLossInfo @endlink
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def FileDownload(self, request, context):
        """*
        @brief return binary stream of file content

        @param Combination of file name, subdirectory and disk type.
        The path is built as follows <mount_dir(disk_type)>/DMAModule/<sub_path(if set)>/<FileName> \n
        The mount directories for different disk types are configured in the servicehub configuration file. See @link FileWriteCommand @endlink.
        @returns binary stream of file content
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_DMAServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Snapshot': grpc.unary_stream_rpc_method_handler(
                    servicer.Snapshot,
                    request_deserializer=dma__pb2.StreamRequest.FromString,
                    response_serializer=dma__pb2.AcquiredData.SerializeToString,
            ),
            'Snapshot32': grpc.unary_stream_rpc_method_handler(
                    servicer.Snapshot32,
                    request_deserializer=dma__pb2.StreamRequest.FromString,
                    response_serializer=dma__pb2.AcquiredData.SerializeToString,
            ),
            'StreamContinuous': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamContinuous,
                    request_deserializer=dma__pb2.StreamRequest.FromString,
                    response_serializer=dma__pb2.AcquiredData.SerializeToString,
            ),
            'GetPackageLossInfo': grpc.unary_unary_rpc_method_handler(
                    servicer.GetPackageLossInfo,
                    request_deserializer=datatypes__pb2.Empty.FromString,
                    response_serializer=dma__pb2.PackageLossInfo.SerializeToString,
            ),
            'FileStreamContinuous': grpc.unary_unary_rpc_method_handler(
                    servicer.FileStreamContinuous,
                    request_deserializer=dma__pb2.FileWriteCommand.FromString,
                    response_serializer=dma__pb2.PackageLossInfo.SerializeToString,
            ),
            'FileSnapshot': grpc.unary_unary_rpc_method_handler(
                    servicer.FileSnapshot,
                    request_deserializer=dma__pb2.FileWriteCommand.FromString,
                    response_serializer=dma__pb2.PackageLossInfo.SerializeToString,
            ),
            'FileSnapshot32': grpc.unary_unary_rpc_method_handler(
                    servicer.FileSnapshot32,
                    request_deserializer=dma__pb2.FileWriteCommand.FromString,
                    response_serializer=dma__pb2.PackageLossInfo.SerializeToString,
            ),
            'FileDownload': grpc.unary_stream_rpc_method_handler(
                    servicer.FileDownload,
                    request_deserializer=dma__pb2.FileRequest.FromString,
                    response_serializer=dma__pb2.FileContent.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'dma.DMAService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('dma.DMAService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class DMAService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def Snapshot(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/dma.DMAService/Snapshot',
            dma__pb2.StreamRequest.SerializeToString,
            dma__pb2.AcquiredData.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Snapshot32(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/dma.DMAService/Snapshot32',
            dma__pb2.StreamRequest.SerializeToString,
            dma__pb2.AcquiredData.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def StreamContinuous(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/dma.DMAService/StreamContinuous',
            dma__pb2.StreamRequest.SerializeToString,
            dma__pb2.AcquiredData.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetPackageLossInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/dma.DMAService/GetPackageLossInfo',
            datatypes__pb2.Empty.SerializeToString,
            dma__pb2.PackageLossInfo.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def FileStreamContinuous(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/dma.DMAService/FileStreamContinuous',
            dma__pb2.FileWriteCommand.SerializeToString,
            dma__pb2.PackageLossInfo.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def FileSnapshot(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/dma.DMAService/FileSnapshot',
            dma__pb2.FileWriteCommand.SerializeToString,
            dma__pb2.PackageLossInfo.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def FileSnapshot32(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/dma.DMAService/FileSnapshot32',
            dma__pb2.FileWriteCommand.SerializeToString,
            dma__pb2.PackageLossInfo.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def FileDownload(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/dma.DMAService/FileDownload',
            dma__pb2.FileRequest.SerializeToString,
            dma__pb2.FileContent.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
