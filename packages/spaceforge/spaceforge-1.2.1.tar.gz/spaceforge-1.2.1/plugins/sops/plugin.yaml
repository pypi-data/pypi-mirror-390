name: Sops
version: 1.0.3
description: |-
  This adds the `SOPS` plugin to your Spacelift account.
  It will decrypt an arbitrary number of files based on config you set.

  ## Usage

  1. Spin up the plugin
  2. Add the autoattach label to any stack that has access to your decryption keys.
  3. The secrets you define in your `.sops.yaml` will automatically be decrypted with your configured `creation_rules`.

  #### .sops.yaml

  The `.sops.yaml` file is a configuration file that tells `sops` how to decrypt your files.
  It is a YAML file that contains a list of `creation_rules` that define how to decrypt your files.
  Read more on sops official repository: https://github.com/getsops/sops

  In addition to the sops config, this plugin also uses the `.sops.yaml` file to determine which files to decrypt.
  simply add a list of `secrets` to your `.sops.yaml` in your working directory and the plugin will decrypt them.

  The following `.sops.yaml` example will decrypt a `test_secret.yaml` file using the defined kms key.
  ```yaml
  creation_rules:
    - kms: arn:aws:kms:us-east-2:694182862388:key/6825a259-28df-43be-80f8-6122eb8a5903

  secrets:
    - test_secret.yaml
  ```
author: Spacelift Team
labels:
- secrets management
- encryption
contexts:
- name_prefix: sops
  description: Main context for Sops
  env: []
  mounted_files:
  - path: /mnt/workspace/plugins/sops/requirements.txt
    content: |-
      sopsy==1.0.1
      pyyaml==6.0.2
    sensitive: false
  - path: /mnt/workspace/plugins/sops/plugin.py
    content: |-
      from pathlib import Path

      import yaml
      from sopsy import Sops, SopsyError

      from spaceforge import Binary, SpaceforgePlugin


      class SopsPlugin(SpaceforgePlugin):
          """
          This adds the `SOPS` plugin to your Spacelift account.
          It will decrypt an arbitrary number of files based on config you set.

          ## Usage

          1. Spin up the plugin
          2. Add the autoattach label to any stack that has access to your decryption keys.
          3. The secrets you define in your `.sops.yaml` will automatically be decrypted with your configured `creation_rules`.

          #### .sops.yaml

          The `.sops.yaml` file is a configuration file that tells `sops` how to decrypt your files.
          It is a YAML file that contains a list of `creation_rules` that define how to decrypt your files.
          Read more on sops official repository: https://github.com/getsops/sops

          In addition to the sops config, this plugin also uses the `.sops.yaml` file to determine which files to decrypt.
          simply add a list of `secrets` to your `.sops.yaml` in your working directory and the plugin will decrypt them.

          The following `.sops.yaml` example will decrypt a `test_secret.yaml` file using the defined kms key.
          ```yaml
          creation_rules:
            - kms: arn:aws:kms:us-east-2:694182862388:key/6825a259-28df-43be-80f8-6122eb8a5903

          secrets:
            - test_secret.yaml
          ```
          """

          # Plugin metadata
          __plugin_name__ = "Sops"
          __labels__ = ["secrets management", "encryption"]
          __version__ = "1.0.3"
          __author__ = "Spacelift Team"

          __binaries__ = [
              Binary(
                  name="sops",
                  download_urls={
                      "amd64": "https://github.com/getsops/sops/releases/download/v3.9.1/sops-v3.9.1.linux.amd64",
                      "arm64": "https://github.com/getsops/sops/releases/download/v3.9.1/sops-v3.9.1.linux.arm64",
                  },
              )
          ]

          def before_init(self):
              if not Path(".sops.yaml").exists():
                  self.logger.error("No .sops.yaml file found.")
                  return

              secrets = Path(".sops.yaml").read_text()
              try:
                  secrets = yaml.safe_load(secrets)
              except yaml.YAMLError as e:
                  self.logger.error(f"Failed to parse .sops.yaml: {e}")
                  return

              if "secrets" not in secrets:
                  self.logger.error("No secrets key found in .sops.yaml.")
                  return
              secrets = secrets["secrets"]

              for secret in secrets:
                  if not Path(secret).exists():
                      self.logger.error(f"Secret file {secret} does not exist.")
                      continue

                  try:
                      self.logger.log(f"Decrypting secret {secret}.")
                      sops = Sops(Path(secret), in_place=True)
                      sops.decrypt()
                      self.logger.log("Decryption successful.")
                  except SopsyError as e:
                      self.logger.error(f"Failed to decrypt secret: {e}")
                  except Exception as e:
                      self.logger.error(f"An unexpected error occurred: {e}")
    sensitive: false
  - path: /mnt/workspace/plugins/sops/binary_install_sops.sh
    content: |-
      #!/bin/sh

      set -e

      export PATH="/mnt/workspace/plugins/plugin_binaries:$PATH"
      if command -v sops; then
          echo "sops is already installed."
          return
      fi

      echo "Installing sops..."
      mkdir -p /mnt/workspace/plugins/plugin_binaries

      ARCH="$(arch)"
      if [ "$ARCH" = "x86_64" ]; then
          URL="https://github.com/getsops/sops/releases/download/v3.9.1/sops-v3.9.1.linux.amd64"
      elif [ "$ARCH" = "arm64" ] || [ "$ARCH" = "aarch64" ]; then
          URL="https://github.com/getsops/sops/releases/download/v3.9.1/sops-v3.9.1.linux.arm64"
      else
          echo "Error: Unsupported architecture '$ARCH'"
          exit 1
      fi

      case "$URL" in
          *.tar.gz|*.tar.bz2|*.zip)
              TMP_DIR=$(mktemp -d)
              trap 'rm -rf "$TMP_DIR"' EXIT

              ARCHIVE="$TMP_DIR/archive"
              curl "$URL" -o "$ARCHIVE" -fL

              case "$URL" in
                  *.tar.gz)
                      tar -xzf "$ARCHIVE" -C "$TMP_DIR" || { echo "Error: Failed to extract archive"; exit 1; }
                      ;;
                  *.tar.bz2)
                      tar -xjf "$ARCHIVE" -C "$TMP_DIR" || { echo "Error: Failed to extract archive"; exit 1; }
                      ;;
                  *.zip)
                      unzip -o "$ARCHIVE" -d "$TMP_DIR" || { echo "Error: Failed to extract archive"; exit 1; }
                      ;;
              esac

              FOUND_BINARY=$(find "$TMP_DIR" -type f -name "sops" | head -n 1)
              if [ -z "$FOUND_BINARY" ]; then
                  echo "Error: Could not find binary 'sops' in extracted archive"
                  exit 1
              fi

              mv "$FOUND_BINARY" "/mnt/workspace/plugins/plugin_binaries/sops"
              ;;
          *)
              curl "$URL" -o "/mnt/workspace/plugins/plugin_binaries/sops" -fL
              ;;
      esac

      chmod +x "/mnt/workspace/plugins/plugin_binaries/sops"
    sensitive: false
  - path: /mnt/workspace/plugins/sops/before_init.sh
    content: |-
      #!/bin/sh

      set -e

      cd /mnt/workspace/plugins/sops

      if [ ! -d "./venv" ]; then
          python -m venv --system-site-packages ./venv
      fi
      . venv/bin/activate

      if ! command -v spaceforge; then
          pip install spaceforge
      fi

      if [ -f requirements.txt ] && [ ! -f .spaceforge_installed_requirements ]; then
          pip install -r requirements.txt
          touch .spaceforge_installed_requirements
      fi

      export PATH="/mnt/workspace/plugins/plugin_binaries:$PATH"

      cd /mnt/workspace/source/$TF_VAR_spacelift_project_root
      python -m spaceforge run --plugin-file /mnt/workspace/plugins/sops/plugin.py before_init
    sensitive: false
  hooks:
    before_init:
    - mkdir -p /mnt/workspace/plugins/sops
    - chmod +x /mnt/workspace/plugins/sops/binary_install_sops.sh && /mnt/workspace/plugins/sops/binary_install_sops.sh
    - chmod +x /mnt/workspace/plugins/sops/before_init.sh && /mnt/workspace/plugins/sops/before_init.sh
