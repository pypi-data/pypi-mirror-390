"""
Unit tests for get_combined_correlation_modules from scself._modules.find_weighted_modules
Generated by claude sonnet 4.5
"""

import pytest
import numpy as np
import anndata as ad
import pandas as pd
from scipy import sparse

from scself._modules.find_weighted_modules import get_combined_correlation_modules
from scself._modules.find_modules import get_correlation_modules


@pytest.fixture
def aligned_adata_list():
    """
    Create a list of aligned anndata objects with the same genes.
    Each dataset has clear modular structure for testing.
    """
    # Common gene names for all datasets
    genes = [f'gene_{i}' for i in range(12)]

    # Dataset 1: Emphasis on module 1 (genes 0-3) and module 2 (genes 4-7)
    X1 = np.array([
        [2, 2, 2, 2, 0, 0, 0, 0, 0.1, 0.1, 0.1, 0.1],
        [2, 2, 2, 2, 0, 0, 0, 0, 0.2, 0.1, 0.1, 0.2],
        [0, 0, 0, 0, 3, 3, 3, 3, 0.1, 0.2, 0.1, 0.1],
        [0, 0, 0, 0, 3, 3, 3, 3, 0.1, 0.1, 0.2, 0.1],
    ])

    # Dataset 2: Emphasis on module 2 (genes 4-7) and module 3 (genes 8-11)
    X2 = np.array([
        [0.1, 0.1, 0.1, 0.1, 2, 2, 2, 2, 0, 0, 0, 0],
        [0.2, 0.1, 0.1, 0.2, 2, 2, 2, 2, 0, 0, 0, 0],
        [0.1, 0.2, 0.1, 0.1, 0, 0, 0, 0, 3, 3, 3, 3],
        [0.1, 0.1, 0.2, 0.1, 0, 0, 0, 0, 3, 3, 3, 3],
    ])

    adata1 = ad.AnnData(
        X1,
        var=pd.DataFrame(index=genes),
        obs=pd.DataFrame(index=[f'cell_{i}' for i in range(4)])
    )

    adata2 = ad.AnnData(
        X2,
        var=pd.DataFrame(index=genes),
        obs=pd.DataFrame(index=[f'cell_{i}' for i in range(4, 8)])
    )

    return [adata1, adata2]


@pytest.fixture
def misaligned_adata_list():
    """
    Create a list of misaligned anndata objects with partially overlapping genes.
    """
    # Dataset 1: genes 0-9
    genes1 = [f'gene_{i}' for i in range(10)]
    X1 = np.array([
        [2, 2, 2, 2, 0, 0, 0, 0, 0.1, 0.1],
        [2, 2, 2, 2, 0, 0, 0, 0, 0.2, 0.1],
        [0, 0, 0, 0, 3, 3, 3, 3, 0.1, 0.2],
        [0, 0, 0, 0, 3, 3, 3, 3, 0.1, 0.1],
    ])

    # Dataset 2: genes 5-14 (overlaps with dataset 1 on genes 5-9)
    genes2 = [f'gene_{i}' for i in range(5, 15)]
    X2 = np.array([
        [2, 2, 2, 2, 0, 0, 0, 0, 0.1, 0.1],
        [2, 2, 2, 2, 0, 0, 0, 0, 0.2, 0.1],
        [0, 0, 0, 0, 3, 3, 3, 3, 0.1, 0.2],
        [0, 0, 0, 0, 3, 3, 3, 3, 0.1, 0.1],
    ])

    adata1 = ad.AnnData(
        X1,
        var=pd.DataFrame(index=genes1),
        obs=pd.DataFrame(index=[f'cell_{i}' for i in range(4)])
    )

    adata2 = ad.AnnData(
        X2,
        var=pd.DataFrame(index=genes2),
        obs=pd.DataFrame(index=[f'cell_{i}' for i in range(4, 8)])
    )

    return [adata1, adata2]


def test_fixtures(aligned_adata_list):

    result = get_correlation_modules(
        aligned_adata_list[0],
        n_neighbors=3
    )

    assert np.array_equal(
        result.var['gene_module'].values[0:8],
        [0] * 4 + [1] * 4
    ) or np.array_equal(
        result.var['gene_module'].values[0:8],
        [1] * 4 + [0] * 4
    )

def test_basic_functionality_aligned(aligned_adata_list):
    """Test basic functionality with aligned datasets."""
    result = get_combined_correlation_modules(
        aligned_adata_list,
        n_neighbors=3
    )

    # Check return type
    assert isinstance(result, ad.AnnData)

    # Check that correlation matrix is square
    assert result.shape[0] == result.shape[1]
    assert result.shape[0] == 12  # Number of genes

    # Check that module assignments were added to original objects
    for adata in aligned_adata_list:
        assert 'gene_module' in adata.var
        assert 'X_umap' in adata.varm
        assert adata.varm['X_umap'].shape == (12, 2)

    # Check that result has expected attributes
    assert 'leiden' in result.obs
    assert 'X_umap' in result.obsm
    assert result.obsm['X_umap'].shape == (12, 2)

    # Check that leiden is integer type
    assert result.obs['leiden'].dtype == int


def test_basic_functionality_misaligned(misaligned_adata_list):
    """Test basic functionality with misaligned datasets."""
    result = get_combined_correlation_modules(
        misaligned_adata_list,
        n_neighbors=3
    )

    # Check that result includes union of all genes
    assert result.shape[0] == 15  # genes 0-14

    # Check that module assignments were added to original objects
    # with appropriate sizes
    assert misaligned_adata_list[0].var['gene_module'].shape[0] == 10
    assert misaligned_adata_list[1].var['gene_module'].shape[0] == 10

    # Check that UMAPs have correct sizes
    assert misaligned_adata_list[0].varm['X_umap'].shape == (10, 2)
    assert misaligned_adata_list[1].varm['X_umap'].shape == (10, 2)


def test_single_dataset(aligned_adata_list):
    """Test with a single dataset in the list."""
    result = get_combined_correlation_modules(
        [aligned_adata_list[0]],
        n_neighbors=3
    )

    assert isinstance(result, ad.AnnData)
    assert result.shape[0] == 12
    assert 'gene_module' in aligned_adata_list[0].var
    assert 'X_umap' in aligned_adata_list[0].varm


def test_custom_layer(aligned_adata_list):
    """Test with custom layer."""
    # Add custom layers
    for adata in aligned_adata_list:
        adata.layers['custom'] = adata.X.copy()

    result = get_combined_correlation_modules(
        aligned_adata_list,
        layer='custom',
        n_neighbors=3
    )

    # Check that correlations were computed for custom layer
    for adata in aligned_adata_list:
        assert 'custom_corrcoef' in adata.varp
        assert 'custom_umap' in adata.varm


def test_mixed_layers(aligned_adata_list):
    """Test with different layers for different datasets."""
    # Add custom layer to second dataset
    aligned_adata_list[1].layers['custom'] = aligned_adata_list[1].X.copy()

    result = get_combined_correlation_modules(
        aligned_adata_list,
        layer=['X', 'custom'],
        n_neighbors=3
    )

    # Check that appropriate correlations were computed
    assert 'X_corrcoef' in aligned_adata_list[0].varp
    assert 'custom_corrcoef' in aligned_adata_list[1].varp
    assert 'X_umap' in aligned_adata_list[0].varm
    assert 'custom_umap' in aligned_adata_list[1].varm


def test_custom_output_key(aligned_adata_list):
    """Test with custom output key."""
    result = get_combined_correlation_modules(
        aligned_adata_list,
        output_key='custom_module',
        n_neighbors=3
    )

    for adata in aligned_adata_list:
        assert 'custom_module' in adata.var
        assert 'gene_module' not in adata.var


def test_obs_mask_single(aligned_adata_list):
    """Test with observation mask for single dataset."""
    # Mask to use only first 2 observations
    mask = np.array([True, True, False, False])

    result = get_combined_correlation_modules(
        [aligned_adata_list[0]],
        obs_mask=[mask],
        n_neighbors=3
    )

    assert isinstance(result, ad.AnnData)
    assert 'gene_module' in aligned_adata_list[0].var


def test_obs_mask_multiple(aligned_adata_list):
    """Test with observation masks for multiple datasets."""
    # Different masks for each dataset
    masks = [
        np.array([True, True, False, False]),
        np.array([False, False, True, True])
    ]

    result = get_combined_correlation_modules(
        aligned_adata_list,
        obs_mask=masks,
        n_neighbors=3
    )

    assert isinstance(result, ad.AnnData)
    for adata in aligned_adata_list:
        assert 'gene_module' in adata.var


def test_obs_mask_slice(aligned_adata_list):
    """Test with slice as observation mask."""
    result = get_combined_correlation_modules(
        [aligned_adata_list[0]],
        obs_mask=[slice(0, 2)],
        n_neighbors=3
    )

    assert isinstance(result, ad.AnnData)
    assert 'gene_module' in aligned_adata_list[0].var


def test_sparse_matrix(aligned_adata_list):
    """Test with sparse matrix input."""
    # Convert to sparse
    for adata in aligned_adata_list:
        adata.X = sparse.csr_matrix(adata.X)

    result = get_combined_correlation_modules(
        aligned_adata_list,
        n_neighbors=3
    )

    assert isinstance(result, ad.AnnData)
    for adata in aligned_adata_list:
        assert 'gene_module' in adata.var
        assert sparse.issparse(adata.X)  # Original should still be sparse


def test_leiden_kwargs(aligned_adata_list):
    """Test that leiden_kwargs are passed through."""
    result = get_combined_correlation_modules(
        aligned_adata_list,
        n_neighbors=3,
        leiden_kwargs={'resolution': 0.5}
    )

    assert isinstance(result, ad.AnnData)
    assert 'leiden' in result.obs


def test_correlation_caching(aligned_adata_list):
    """Test that correlation is cached and reused."""
    # Run once to compute correlation
    result1 = get_combined_correlation_modules(
        aligned_adata_list,
        layer='X',
        n_neighbors=3
    )

    # Store correlation from first dataset
    corr1 = aligned_adata_list[0].varp['X_corrcoef'].copy()

    # Run again - should use cached correlation
    result2 = get_combined_correlation_modules(
        aligned_adata_list,
        layer='X',
        n_neighbors=3
    )

    # Correlation should be identical (cached)
    assert np.allclose(corr1, aligned_adata_list[0].varp['X_corrcoef'])


def test_averaging_behavior(aligned_adata_list):
    """Test that correlations are properly averaged."""
    # Create two datasets with identical structure
    genes = [f'gene_{i}' for i in range(4)]

    # Perfect correlation in dataset 1
    X1 = np.array([
        [1, 1, 0, 0],
        [1, 1, 0, 0],
        [0, 0, 1, 1],
        [0, 0, 1, 1],
    ])

    # Perfect correlation in dataset 2
    X2 = np.array([
        [2, 2, 0, 0],
        [2, 2, 0, 0],
        [0, 0, 2, 2],
        [0, 0, 2, 2],
    ])

    adata1 = ad.AnnData(X1, var=pd.DataFrame(index=genes))
    adata2 = ad.AnnData(X2, var=pd.DataFrame(index=genes))

    result = get_combined_correlation_modules([adata1, adata2], n_neighbors=2)

    # Genes 0 and 1 should be perfectly correlated
    # Genes 2 and 3 should be perfectly correlated
    # Cross-module correlations should be low/negative
    assert result.layers['X_corrcoef'][0, 1] > 0.9  # High correlation within module
    assert result.layers['X_corrcoef'][2, 3] > 0.9  # High correlation within module
    assert result.layers['X_corrcoef'][0, 2] < 0.5  # Low correlation across modules


def test_partial_overlap(misaligned_adata_list):
    """Test averaging with partial gene overlap."""
    result = get_combined_correlation_modules(
        misaligned_adata_list,
        n_neighbors=3
    )

    # Check that non-overlapping genes still have correlations
    # (they should be computed from the single dataset that has them)
    assert not np.any(np.isnan(result.layers['X_corrcoef']))

    # Gene union should be correct
    expected_genes = [f'gene_{i}' for i in range(15)]
    assert set(result.var_names) == set(expected_genes)


def test_layer_length_mismatch(aligned_adata_list):
    """Test error handling when layer list has wrong length."""
    with pytest.raises(AttributeError, match="len\\(layer\\)"):
        get_combined_correlation_modules(
            aligned_adata_list,
            layer=['X'],  # Wrong length (should be 2)
            n_neighbors=3
        )


def test_empty_dataset_list():
    """Test error handling with empty dataset list."""
    with pytest.raises(Exception):
        get_combined_correlation_modules([], n_neighbors=3)


def test_var_names_preservation(aligned_adata_list):
    """Test that var_names are preserved in original objects."""
    original_names = [adata.var_names.copy() for adata in aligned_adata_list]

    result = get_combined_correlation_modules(
        aligned_adata_list,
        n_neighbors=3
    )

    # Check that original var_names are unchanged
    for adata, orig_names in zip(aligned_adata_list, original_names):
        assert adata.var_names.equals(orig_names)


def test_three_datasets():
    """Test with three datasets."""
    genes = [f'gene_{i}' for i in range(6)]

    X1 = np.array([[1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0]])
    X2 = np.array([[0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0]])
    X3 = np.array([[0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1]])

    adata_list = [
        ad.AnnData(X1, var=pd.DataFrame(index=genes)),
        ad.AnnData(X2, var=pd.DataFrame(index=genes)),
        ad.AnnData(X3, var=pd.DataFrame(index=genes))
    ]

    result = get_combined_correlation_modules(adata_list, n_neighbors=2)

    assert result.shape[0] == 6
    for adata in adata_list:
        assert 'gene_module' in adata.var


def test_very_small_dataset():
    """Test with very small dataset (fewer genes than n_neighbors)."""
    genes = [f'gene_{i}' for i in range(3)]
    X = np.array([[1, 0, 0], [0, 1, 0]])

    adata = ad.AnnData(X, var=pd.DataFrame(index=genes))

    # Should handle gracefully when n_neighbors is too large
    result = get_combined_correlation_modules([adata], n_neighbors=10)

    assert isinstance(result, ad.AnnData)
    assert 'gene_module' in adata.var


def test_identical_genes_different_order():
    """Test with same genes in different order across datasets."""
    genes1 = ['gene_a', 'gene_b', 'gene_c', 'gene_d']
    genes2 = ['gene_c', 'gene_d', 'gene_a', 'gene_b']

    X1 = np.array([[1, 1, 0, 0], [1, 1, 0, 0]])
    X2 = np.array([[0, 0, 1, 1], [0, 0, 1, 1]])

    adata1 = ad.AnnData(X1, var=pd.DataFrame(index=genes1))
    adata2 = ad.AnnData(X2, var=pd.DataFrame(index=genes2))

    result = get_combined_correlation_modules([adata1, adata2], n_neighbors=2)

    # Should handle reindexing correctly
    assert result.shape[0] == 4
    assert set(result.var_names) == set(genes1)


def test_result_correlation_matrix_properties(aligned_adata_list):
    """Test properties of the resulting correlation matrix."""
    result = get_combined_correlation_modules(
        aligned_adata_list,
        n_neighbors=3
    )

    # Correlation matrix should be symmetric
    assert np.allclose(result.layers['X_corrcoef'], result.layers['X_corrcoef'].T)

    # Diagonal should be 1 (correlation with self)
    assert np.allclose(np.diag(result.layers['X_corrcoef']), 1.0)

    # Values should be in [-1, 1]
    assert np.all(result.layers['X_corrcoef'] >= -1.0)
    assert np.all(result.layers['X_corrcoef'] <= 1.0)


def test_no_overlapping_genes():
    """Test with completely non-overlapping gene sets."""
    genes1 = ['gene_a', 'gene_b', 'gene_c']
    genes2 = ['gene_d', 'gene_e', 'gene_f']

    X1 = np.array([[1, 1, 0], [0, 1, 1]])
    X2 = np.array([[1, 0, 1], [1, 1, 0]])

    adata1 = ad.AnnData(X1, var=pd.DataFrame(index=genes1))
    adata2 = ad.AnnData(X2, var=pd.DataFrame(index=genes2))

    result = get_combined_correlation_modules([adata1, adata2], n_neighbors=2)

    # Should create union of all genes
    assert result.shape[0] == 6
    assert set(result.var_names) == set(genes1 + genes2)
