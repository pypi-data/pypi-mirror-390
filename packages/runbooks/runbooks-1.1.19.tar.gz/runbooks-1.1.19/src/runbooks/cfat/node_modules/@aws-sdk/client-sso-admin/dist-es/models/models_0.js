import { SSOAdminServiceException as __BaseException } from "./SSOAdminServiceException";
export const AccessDeniedExceptionReason = {
    KMS_ACCESS_DENIED_EXCEPTION: "KMS_AccessDeniedException",
};
export class AccessDeniedException extends __BaseException {
    name = "AccessDeniedException";
    $fault = "client";
    Message;
    Reason;
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
        this.Message = opts.Message;
        this.Reason = opts.Reason;
    }
}
export const PrincipalType = {
    GROUP: "GROUP",
    USER: "USER",
};
export const StatusValues = {
    FAILED: "FAILED",
    IN_PROGRESS: "IN_PROGRESS",
    SUCCEEDED: "SUCCEEDED",
};
export const TargetType = {
    AWS_ACCOUNT: "AWS_ACCOUNT",
};
export const SignInOrigin = {
    APPLICATION: "APPLICATION",
    IDENTITY_CENTER: "IDENTITY_CENTER",
};
export const ApplicationVisibility = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
export const ApplicationStatus = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
export class ConflictException extends __BaseException {
    name = "ConflictException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ConflictException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ConflictException.prototype);
        this.Message = opts.Message;
    }
}
export class InternalServerException extends __BaseException {
    name = "InternalServerException";
    $fault = "server";
    Message;
    constructor(opts) {
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts,
        });
        Object.setPrototypeOf(this, InternalServerException.prototype);
        this.Message = opts.Message;
    }
}
export const ResourceNotFoundExceptionReason = {
    KMS_NOT_FOUND_EXCEPTION: "KMS_NotFoundException",
};
export class ResourceNotFoundException extends __BaseException {
    name = "ResourceNotFoundException";
    $fault = "client";
    Message;
    Reason;
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
        this.Message = opts.Message;
        this.Reason = opts.Reason;
    }
}
export const ThrottlingExceptionReason = {
    KMS_THROTTLING_EXCEPTION: "KMS_ThrottlingException",
};
export class ThrottlingException extends __BaseException {
    name = "ThrottlingException";
    $fault = "client";
    Message;
    Reason;
    constructor(opts) {
        super({
            name: "ThrottlingException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ThrottlingException.prototype);
        this.Message = opts.Message;
        this.Reason = opts.Reason;
    }
}
export const ValidationExceptionReason = {
    KMS_DISABLED_EXCEPTION: "KMS_DisabledException",
    KMS_INVALID_KEY_USAGE_EXCEPTION: "KMS_InvalidKeyUsageException",
    KMS_INVALID_STATE_EXCEPTION: "KMS_InvalidStateException",
};
export class ValidationException extends __BaseException {
    name = "ValidationException";
    $fault = "client";
    Message;
    Reason;
    constructor(opts) {
        super({
            name: "ValidationException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ValidationException.prototype);
        this.Message = opts.Message;
        this.Reason = opts.Reason;
    }
}
export const AuthenticationMethodType = {
    IAM: "IAM",
};
export var AuthenticationMethod;
(function (AuthenticationMethod) {
    AuthenticationMethod.visit = (value, visitor) => {
        if (value.Iam !== undefined)
            return visitor.Iam(value.Iam);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(AuthenticationMethod || (AuthenticationMethod = {}));
export const GrantType = {
    AUTHORIZATION_CODE: "authorization_code",
    JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer",
    REFRESH_TOKEN: "refresh_token",
    TOKEN_EXCHANGE: "urn:ietf:params:oauth:grant-type:token-exchange",
};
export var Grant;
(function (Grant) {
    Grant.visit = (value, visitor) => {
        if (value.AuthorizationCode !== undefined)
            return visitor.AuthorizationCode(value.AuthorizationCode);
        if (value.JwtBearer !== undefined)
            return visitor.JwtBearer(value.JwtBearer);
        if (value.RefreshToken !== undefined)
            return visitor.RefreshToken(value.RefreshToken);
        if (value.TokenExchange !== undefined)
            return visitor.TokenExchange(value.TokenExchange);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(Grant || (Grant = {}));
export const FederationProtocol = {
    OAUTH: "OAUTH",
    SAML: "SAML",
};
export class ServiceQuotaExceededException extends __BaseException {
    name = "ServiceQuotaExceededException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ServiceQuotaExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ServiceQuotaExceededException.prototype);
        this.Message = opts.Message;
    }
}
export const JwksRetrievalOption = {
    OPEN_ID_DISCOVERY: "OPEN_ID_DISCOVERY",
};
export var TrustedTokenIssuerConfiguration;
(function (TrustedTokenIssuerConfiguration) {
    TrustedTokenIssuerConfiguration.visit = (value, visitor) => {
        if (value.OidcJwtConfiguration !== undefined)
            return visitor.OidcJwtConfiguration(value.OidcJwtConfiguration);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(TrustedTokenIssuerConfiguration || (TrustedTokenIssuerConfiguration = {}));
export const TrustedTokenIssuerType = {
    OIDC_JWT: "OIDC_JWT",
};
export const KmsKeyStatus = {
    ENABLED: "ENABLED",
    UPDATE_FAILED: "UPDATE_FAILED",
    UPDATING: "UPDATING",
};
export const KmsKeyType = {
    AWS_OWNED_KMS_KEY: "AWS_OWNED_KMS_KEY",
    CUSTOMER_MANAGED_KEY: "CUSTOMER_MANAGED_KEY",
};
export const InstanceStatus = {
    ACTIVE: "ACTIVE",
    CREATE_FAILED: "CREATE_FAILED",
    CREATE_IN_PROGRESS: "CREATE_IN_PROGRESS",
    DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS",
};
export const InstanceAccessControlAttributeConfigurationStatus = {
    CREATION_FAILED: "CREATION_FAILED",
    CREATION_IN_PROGRESS: "CREATION_IN_PROGRESS",
    ENABLED: "ENABLED",
};
export const UserBackgroundSessionApplicationStatus = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
export const ProvisioningStatus = {
    LATEST_PERMISSION_SET_NOT_PROVISIONED: "LATEST_PERMISSION_SET_NOT_PROVISIONED",
    LATEST_PERMISSION_SET_PROVISIONED: "LATEST_PERMISSION_SET_PROVISIONED",
};
export const ProvisionTargetType = {
    ALL_PROVISIONED_ACCOUNTS: "ALL_PROVISIONED_ACCOUNTS",
    AWS_ACCOUNT: "AWS_ACCOUNT",
};
export var TrustedTokenIssuerUpdateConfiguration;
(function (TrustedTokenIssuerUpdateConfiguration) {
    TrustedTokenIssuerUpdateConfiguration.visit = (value, visitor) => {
        if (value.OidcJwtConfiguration !== undefined)
            return visitor.OidcJwtConfiguration(value.OidcJwtConfiguration);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(TrustedTokenIssuerUpdateConfiguration || (TrustedTokenIssuerUpdateConfiguration = {}));
