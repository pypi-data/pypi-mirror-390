# Code generated by smithy-python-codegen DO NOT EDIT.

from copy import deepcopy
import logging

from smithy_core.aio.client import ClientCall, RequestPipeline
from smithy_core.aio.eventstream import DuplexEventStream
from smithy_core.exceptions import ExpectationNotMetError
from smithy_core.interceptors import InterceptorChain
from smithy_core.types import TypedProperties
from smithy_http.plugins import user_agent_plugin

from .config import Config, Plugin
from .models import (
    AudioStream,
    CallAnalyticsTranscriptResultStream,
    GET_MEDICAL_SCRIBE_STREAM,
    GetMedicalScribeStreamInput,
    GetMedicalScribeStreamOutput,
    MedicalScribeInputStream,
    MedicalScribeResultStream,
    MedicalTranscriptResultStream,
    START_CALL_ANALYTICS_STREAM_TRANSCRIPTION,
    START_MEDICAL_SCRIBE_STREAM,
    START_MEDICAL_STREAM_TRANSCRIPTION,
    START_STREAM_TRANSCRIPTION,
    StartCallAnalyticsStreamTranscriptionInput,
    StartCallAnalyticsStreamTranscriptionOutput,
    StartMedicalScribeStreamInput,
    StartMedicalScribeStreamOutput,
    StartMedicalStreamTranscriptionInput,
    StartMedicalStreamTranscriptionOutput,
    StartStreamTranscriptionInput,
    StartStreamTranscriptionOutput,
    TranscriptResultStream,
    _CallAnalyticsTranscriptResultStreamDeserializer,
    _MedicalScribeResultStreamDeserializer,
    _MedicalTranscriptResultStreamDeserializer,
    _TranscriptResultStreamDeserializer,
)
from .user_agent import aws_user_agent_plugin


logger = logging.getLogger(__name__)


class TranscribeStreamingClient:
    """
    Amazon Transcribe streaming offers four main types of real-time transcription: **Standard**, **Medical**, **Call Analytics**, and **Health Scribe**.

    * **Standard transcriptions** are the most common option. Refer to for details.

    * **Medical transcriptions** are tailored to medical professionals and incorporate medical terms. A common use case for this service is transcribing doctor-patient dialogue in real time, so doctors can focus on their patient instead of taking notes. Refer to for details.

    * **Call Analytics transcriptions** are designed for use with call center audio on two different channels; if you're looking for insight into customer service calls, use this option. Refer to for details.

    * **HealthScribe transcriptions** are designed to automatically create clinical notes from patient-clinician conversations using generative AI. Refer to [here] for details.

    :param config: Optional configuration for the client. Here you can set things like the
        endpoint for HTTP services or auth credentials.

    :param plugins: A list of callables that modify the configuration dynamically. These
        can be used to set defaults, for example.
    """

    def __init__(
        self, config: Config | None = None, plugins: list[Plugin] | None = None
    ):
        self._config = config or Config()

        client_plugins: list[Plugin] = [aws_user_agent_plugin, user_agent_plugin]
        if plugins:
            client_plugins.extend(plugins)

        for plugin in client_plugins:
            plugin(self._config)

    async def get_medical_scribe_stream(
        self, input: GetMedicalScribeStreamInput, plugins: list[Plugin] | None = None
    ) -> GetMedicalScribeStreamOutput:
        """
        Provides details about the specified Amazon Web Services HealthScribe streaming
        session. To view the status of the streaming session, check the ``StreamStatus``
        field in the response. To get the details of post-stream analytics, including
        its status, check the ``PostStreamAnalyticsResult`` field in the response.

        :param input: The operation's input.

        :param plugins: A list of callables that modify the configuration dynamically.
            Changes made by these plugins only apply for the duration of the operation
            execution and will not affect any other operation invocations.
        """
        operation_plugins: list[Plugin] = []
        if plugins:
            operation_plugins.extend(plugins)
        config = deepcopy(self._config)
        for plugin in operation_plugins:
            plugin(config)
        if config.protocol is None or config.transport is None:
            raise ExpectationNotMetError(
                "protocol and transport MUST be set on the config to make calls."
            )
        pipeline = RequestPipeline(protocol=config.protocol, transport=config.transport)
        call = ClientCall(
            input=input,
            operation=GET_MEDICAL_SCRIBE_STREAM,
            context=TypedProperties({"config": config}),
            interceptor=InterceptorChain(config.interceptors),
            auth_scheme_resolver=config.auth_scheme_resolver,
            supported_auth_schemes=config.auth_schemes,
            endpoint_resolver=config.endpoint_resolver,
            retry_strategy=config.retry_strategy,
        )

        return await pipeline(call)

    async def start_call_analytics_stream_transcription(
        self,
        input: StartCallAnalyticsStreamTranscriptionInput,
        plugins: list[Plugin] | None = None,
    ) -> DuplexEventStream[
        AudioStream,
        CallAnalyticsTranscriptResultStream,
        StartCallAnalyticsStreamTranscriptionOutput,
    ]:
        """
        Starts a bidirectional HTTP/2 or WebSocket stream where audio is streamed to
        Amazon Transcribe and the transcription results are streamed to your
        application. Use this operation for `Call Analytics <https://docs.aws.amazon.com/transcribe/latest/dg/call-analytics.html>`_
        transcriptions.

        The following parameters are required:

        * ``language-code`` or ``identify-language``

        * ``media-encoding``

        * ``sample-rate``

        For more information on streaming with Amazon Transcribe, see `Transcribing streaming audio <https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html>`_
        .

        :param input: The operation's input.

        :param plugins: A list of callables that modify the configuration dynamically.
            Changes made by these plugins only apply for the duration of the operation
            execution and will not affect any other operation invocations.
        """
        operation_plugins: list[Plugin] = []
        if plugins:
            operation_plugins.extend(plugins)
        config = deepcopy(self._config)
        for plugin in operation_plugins:
            plugin(config)
        if config.protocol is None or config.transport is None:
            raise ExpectationNotMetError(
                "protocol and transport MUST be set on the config to make calls."
            )
        pipeline = RequestPipeline(protocol=config.protocol, transport=config.transport)
        call = ClientCall(
            input=input,
            operation=START_CALL_ANALYTICS_STREAM_TRANSCRIPTION,
            context=TypedProperties({"config": config}),
            interceptor=InterceptorChain(config.interceptors),
            auth_scheme_resolver=config.auth_scheme_resolver,
            supported_auth_schemes=config.auth_schemes,
            endpoint_resolver=config.endpoint_resolver,
            retry_strategy=config.retry_strategy,
        )

        return await pipeline.duplex_stream(
            call,
            AudioStream,
            CallAnalyticsTranscriptResultStream,
            _CallAnalyticsTranscriptResultStreamDeserializer().deserialize,
        )

    async def start_medical_scribe_stream(
        self, input: StartMedicalScribeStreamInput, plugins: list[Plugin] | None = None
    ) -> DuplexEventStream[
        MedicalScribeInputStream,
        MedicalScribeResultStream,
        StartMedicalScribeStreamOutput,
    ]:
        """
        Starts a bidirectional HTTP/2 stream, where audio is streamed to Amazon Web
        Services HealthScribe and the transcription results are streamed to your
        application.

        When you start a stream, you first specify the stream configuration in a
        ``MedicalScribeConfigurationEvent``. This event includes channel definitions,
        encryption settings, medical scribe context, and post-stream analytics settings,
        such as the output configuration for aggregated transcript and clinical note
        generation. These are additional streaming session configurations beyond those
        provided in your initial start request headers. Whether you are starting a new
        session or resuming an existing session, your first event must be a
        ``MedicalScribeConfigurationEvent``.

         After you send a ``MedicalScribeConfigurationEvent``, you start ``AudioEvents``
         and Amazon Web Services HealthScribe responds with real-time transcription
         results. When you are finished, to start processing the results with the
         post-stream analytics, send a ``MedicalScribeSessionControlEvent`` with a
         ``Type`` of ``END_OF_SESSION`` and Amazon Web Services HealthScribe starts the
         analytics.

        You can pause or resume streaming. To pause streaming, complete the input stream
        without sending the ``MedicalScribeSessionControlEvent``. To resume streaming,
        call the ``StartMedicalScribeStream`` and specify the same SessionId you used to
        start the stream.

        The following parameters are required:

        * ``language-code``

        * ``media-encoding``

        * ``media-sample-rate-hertz``

        For more information on streaming with Amazon Web Services HealthScribe, see
        `Amazon Web Services HealthScribe <https://docs.aws.amazon.com/transcribe/latest/dg/health-scribe-streaming.html>`_
        .

        :param input: The operation's input.

        :param plugins: A list of callables that modify the configuration dynamically.
            Changes made by these plugins only apply for the duration of the operation
            execution and will not affect any other operation invocations.
        """
        operation_plugins: list[Plugin] = []
        if plugins:
            operation_plugins.extend(plugins)
        config = deepcopy(self._config)
        for plugin in operation_plugins:
            plugin(config)
        if config.protocol is None or config.transport is None:
            raise ExpectationNotMetError(
                "protocol and transport MUST be set on the config to make calls."
            )
        pipeline = RequestPipeline(protocol=config.protocol, transport=config.transport)
        call = ClientCall(
            input=input,
            operation=START_MEDICAL_SCRIBE_STREAM,
            context=TypedProperties({"config": config}),
            interceptor=InterceptorChain(config.interceptors),
            auth_scheme_resolver=config.auth_scheme_resolver,
            supported_auth_schemes=config.auth_schemes,
            endpoint_resolver=config.endpoint_resolver,
            retry_strategy=config.retry_strategy,
        )

        return await pipeline.duplex_stream(
            call,
            MedicalScribeInputStream,
            MedicalScribeResultStream,
            _MedicalScribeResultStreamDeserializer().deserialize,
        )

    async def start_medical_stream_transcription(
        self,
        input: StartMedicalStreamTranscriptionInput,
        plugins: list[Plugin] | None = None,
    ) -> DuplexEventStream[
        AudioStream,
        MedicalTranscriptResultStream,
        StartMedicalStreamTranscriptionOutput,
    ]:
        """
        Starts a bidirectional HTTP/2 or WebSocket stream where audio is streamed to
        Amazon Transcribe Medical and the transcription results are streamed to your
        application.

        The following parameters are required:

        * ``language-code``

        * ``media-encoding``

        * ``sample-rate``

        For more information on streaming with Amazon Transcribe Medical, see
        `Transcribing streaming audio <https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html>`_
        .

        :param input: The operation's input.

        :param plugins: A list of callables that modify the configuration dynamically.
            Changes made by these plugins only apply for the duration of the operation
            execution and will not affect any other operation invocations.
        """
        operation_plugins: list[Plugin] = []
        if plugins:
            operation_plugins.extend(plugins)
        config = deepcopy(self._config)
        for plugin in operation_plugins:
            plugin(config)
        if config.protocol is None or config.transport is None:
            raise ExpectationNotMetError(
                "protocol and transport MUST be set on the config to make calls."
            )
        pipeline = RequestPipeline(protocol=config.protocol, transport=config.transport)
        call = ClientCall(
            input=input,
            operation=START_MEDICAL_STREAM_TRANSCRIPTION,
            context=TypedProperties({"config": config}),
            interceptor=InterceptorChain(config.interceptors),
            auth_scheme_resolver=config.auth_scheme_resolver,
            supported_auth_schemes=config.auth_schemes,
            endpoint_resolver=config.endpoint_resolver,
            retry_strategy=config.retry_strategy,
        )

        return await pipeline.duplex_stream(
            call,
            AudioStream,
            MedicalTranscriptResultStream,
            _MedicalTranscriptResultStreamDeserializer().deserialize,
        )

    async def start_stream_transcription(
        self, input: StartStreamTranscriptionInput, plugins: list[Plugin] | None = None
    ) -> DuplexEventStream[
        AudioStream, TranscriptResultStream, StartStreamTranscriptionOutput
    ]:
        """
        Starts a bidirectional HTTP/2 or WebSocket stream where audio is streamed to
        Amazon Transcribe and the transcription results are streamed to your
        application.

        The following parameters are required:

        * ``language-code`` or ``identify-language`` or ``identify-multiple-language``

        * ``media-encoding``

        * ``sample-rate``

        For more information on streaming with Amazon Transcribe, see `Transcribing streaming audio <https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html>`_
        .

        :param input: The operation's input.

        :param plugins: A list of callables that modify the configuration dynamically.
            Changes made by these plugins only apply for the duration of the operation
            execution and will not affect any other operation invocations.
        """
        operation_plugins: list[Plugin] = []
        if plugins:
            operation_plugins.extend(plugins)
        config = deepcopy(self._config)
        for plugin in operation_plugins:
            plugin(config)
        if config.protocol is None or config.transport is None:
            raise ExpectationNotMetError(
                "protocol and transport MUST be set on the config to make calls."
            )
        pipeline = RequestPipeline(protocol=config.protocol, transport=config.transport)
        call = ClientCall(
            input=input,
            operation=START_STREAM_TRANSCRIPTION,
            context=TypedProperties({"config": config}),
            interceptor=InterceptorChain(config.interceptors),
            auth_scheme_resolver=config.auth_scheme_resolver,
            supported_auth_schemes=config.auth_schemes,
            endpoint_resolver=config.endpoint_resolver,
            retry_strategy=config.retry_strategy,
        )

        return await pipeline.duplex_stream(
            call,
            AudioStream,
            TranscriptResultStream,
            _TranscriptResultStreamDeserializer().deserialize,
        )
