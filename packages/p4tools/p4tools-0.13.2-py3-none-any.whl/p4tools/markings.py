"""module to work with both fan and blotch markings graphically"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/01_markings.ipynb.

# %% auto 0
__all__ = ['IMG_X_SIZE', 'IMG_Y_SIZE', 'calc_fig_size', 'show_subframe', 'set_subframe_size', 'Blotch', 'Blotches',
           'TileBlotches', 'rotate_vector', 'Fan', 'Fans', 'TileFans']

# %% ../notebooks/01_markings.ipynb 2
import math
from math import cos, degrees, pi, radians, sin
from pathlib import Path

import matplotlib.lines as lines
import matplotlib.patches as mpatches
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from matplotlib.collections import PatchCollection, LineCollection
from matplotlib.patches import Ellipse
from numpy import arctan2
from numpy import linalg as LA
from shapely import affinity
from shapely import geometry as geom

from . import io

# %% ../notebooks/01_markings.ipynb 3
IMG_X_SIZE = 840
IMG_Y_SIZE = 648

# %% ../notebooks/01_markings.ipynb 4
def calc_fig_size(width):
    """Calc figure height in ratio of subframes."""
    ratio = IMG_X_SIZE / IMG_Y_SIZE
    return (width, width / ratio)

# %% ../notebooks/01_markings.ipynb 5
def show_subframe(tile_id, ax=None, aspect="auto"):
    subframe = io.get_subframe_by_tile_id(tile_id)
    if ax is None:
        _, ax = plt.subplots(figsize=calc_fig_size(8))
    ax.imshow(subframe, origin="upper", aspect=aspect)
    ax.set_axis_off()
    return ax

# %% ../notebooks/01_markings.ipynb 6
def set_subframe_size(ax):
    """Set plot view limit on Planet 4 subframe size."""
    ax.set_xlim(0, IMG_X_SIZE)
    ax.set_ylim(IMG_Y_SIZE, 0)

# %% ../notebooks/01_markings.ipynb 7
class Blotch(Ellipse):
    to_average = "x y image_x image_y angle radius_1 radius_2".split()

    @classmethod
    def from_tile_id(cls, tile_id, n=0, **kwargs):
        df = io.get_blotch_catalog()
        data = df[df.tile_id == tile_id].iloc[n]
        return cls(data, **kwargs)

    @classmethod
    def from_marking_id(cls, marking_id, version=None, **kwargs):
        """Factory to create a Blotch from a stable marking_id.

        If `version` is provided, it is passed to the catalog accessor when possible.
        """
        # support both signatures io.get_blotch_catalog() and io.get_blotch_catalog(version)
        if version is None:
            df = io.get_blotch_catalog()
        else:
            try:
                df = io.get_blotch_catalog(version)
            except TypeError:
                df = io.get_blotch_catalog()
        sel = df[df.marking_id == marking_id]
        if sel.empty:
            raise KeyError(f"marking_id {marking_id!r} not found in blotch catalog")
        data = sel.squeeze()
        return cls(data, **kwargs)

    def __init__(
        self,
        data,  # object with blotch data attributes: x, y, radius_1, radius_2, angle
        scope="planet4",  # "planet4" or "hirise",
        with_center=False,  # if True, plot the center of the blotch,
        url_db="",  # path to the url database,
        **kwargs,
    ):
        """
        Blotch management class for P4.

        Attributes
        ----------
        to_average : list
            List of cols to be averaged after clustering
        data : object with blotch data attributes, as provided by `data`
        center : tuple (inherited from matplotlib.Ellipse)
            Coordinates of center, i.e. self.x, self.y
        """
        self.data = data
        self.scope = scope if scope is not None else "planet4"
        self.with_center = with_center
        self.url_db = Path(url_db)
        self.ax = None
        if scope not in ["hirise", "planet4"]:
            raise TypeError("Unknown scope: {}".format(scope))
        try:
            self.x = data.x if scope == "planet4" else data.image_x
            self.y = data.y if scope == "planet4" else data.image_y
        except AttributeError:
            print("No x and y attributes in data:\n{}".format(data))
            raise AttributeError
        # default member number is 1. This is set to the cluster member inside
        # clustering execution.
        self._n_members = 1
        super().__init__(
            (self.x, self.y),
            data.radius_1 * 2,
            data.radius_2 * 2,
            angle=data.angle,
            alpha=0.65,
            linewidth=2,
            fill=False,
            **kwargs,
        )
        self.data = data

    @property
    def tile_id(self):
        return self.data.tile_id

    @property
    def subframe(self):
        return io.get_subframe_by_tile_id(self.data.tile_id)

    def show_subframe(self, ax=None, aspect="auto"):
        if ax is None:
            _, ax = plt.subplots(figsize=calc_fig_size(8))
        ax.imshow(self.subframe, origin="upper", aspect=aspect)
        ax.set_axis_off()
        self.ax = ax

    def is_equal(self, other):
        if (
            self.data.x == other.data.x
            and self.data.y == other.data.y
            and self.data.image_x == other.data.image_y
            and self.data.image_y == other.data.image_y
            and self.data.radius_1 == other.data.radius_1
            and self.data.radius_2 == other.data.radius_2
            and self.data.angle == other.data.angle
        ):
            return True
        else:
            return False

    def to_shapely(self):
        """Convert a markings.Blotch to shapely Ellipse.

        Code from https://gis.stackexchange.com/questions/243459/drawing-ellipse-with-shapely/243462
        """
        circ = geom.Point(self.center).buffer(1)
        ell = affinity.scale(circ, self.data.radius_1, self.data.radius_2)
        ellr = affinity.rotate(ell, self.data.angle)
        return ellr

    @property
    def area(self):
        return pi * self.data.radius_1 * self.data.radius_2

    @property
    def x1(self):
        return math.cos(math.radians(self.angle)) * self.data.radius_1

    @property
    def y1(self):
        return math.sin(self.angle) * self.data.radius_1

    @property
    def p1(self):
        return np.array(self.center) + np.array([self.x1, self.y1])

    @property
    def p2(self):
        return np.array(self.center) - np.array([self.x1, self.y1])

    @property
    def x2(self):
        return math.cos(math.radians(self.angle + 90)) * self.data.radius_2

    @property
    def y2(self):
        return math.sin(math.radians(self.angle + 90)) * self.data.radius_2

    @property
    def p3(self):
        return np.array(self.center) + np.array([self.x2, self.y2])

    @property
    def p4(self):
        return np.array(self.center) - np.array([self.x2, self.y2])

    @property
    def limit_points(self):
        return [self.p1, self.p2, self.p3, self.p4]

    def plot_center(self, ax, color="b"):
        # return the scatter object so it can be removed later if needed
        return ax.scatter(self.x, self.y, color=color, s=20, marker=".")

    def plot_limit_points(self, ax, color="b"):
        for x, y in self.limit_points:
            ax.scatter(x, y, color=color, s=20, marker="o")

    @property
    def n_members(self):
        return self._n_members

    @n_members.setter
    def n_members(self, value):
        self._n_members = value

    def plot(self, color="red", ax=None):
        if ax is None:
            _, ax = plt.subplots()
        self.show_subframe(ax)
        ax = self.ax
        # If we've drawn before, remove the previous patch to keep plotting idempotent
        if hasattr(self, "_last_patch") and self._last_patch is not None:
            try:
                self._last_patch.remove()
            except Exception:
                pass
        # Create a fresh Ellipse patch instead of adding the same artist
        patch = mpatches.Ellipse(
            (self.x, self.y),
            self.data.radius_1 * 2,
            self.data.radius_2 * 2,
            angle=self.data.angle,
            alpha=0.65,
            linewidth=2,
            fill=False,
        )
        if color is not None:
            patch.set_edgecolor(color)
        ax.add_patch(patch)
        if self.with_center:
            # If we've drawn a center marker before, try to remove it first
            if hasattr(self, "_last_center") and self._last_center is not None:
                try:
                    self._last_center.remove()
                except Exception:
                    pass
            # plot_center returns the PathCollection (from scatter) which we can store
            self._last_center = ax.scatter(self.x, self.y, color=color, s=20, marker=".") if self.with_center else None
        set_subframe_size(ax)
        # remember last drawn patch in case the caller wants to remove it later
        self._last_patch = patch

    def store(self, fpath=None):
        out = self.data
        for p in range(1, 5):
            attr = "p" + str(p)
            point = getattr(self, attr)
            out[attr + "_x"] = point[0]
            out[attr + "_y"] = point[1]
        if "image_id" not in out.index:
            pass
            # out['image_id'] = self.image_id
        if fpath is not None:
            out.to_hdf(str(fpath.with_suffix(".hdf")), "df")
        out["n_members"] = self.n_members
        return out

    def __str__(self):
        s = "markings.Blotch object. Input data:\n"
        s += self.data.__str__()
        s += "\n"
        s += "N_members: {}".format(self.n_members)
        return s

    def __repr__(self):
        # Prefer eval-friendly factory when marking_id is available, but include metadata comment
        mid = self.data.marking_id
        tile = self.data.tile_id
        area = float(self.area)
        meta = f"tile_id={tile!r}, area={area!r}"
        if mid is not None:
            return f"Blotch.from_marking_id({mid!r})  # {meta}"
        # fallback concise summary with metadata comment
        try:
            r1 = float(self.data.radius_1)
            r2 = float(self.data.radius_2)
        except Exception:
            r1 = getattr(self.data, "radius_1", None)
            r2 = getattr(self.data, "radius_2", None)
        return f"Blotch(marking_id={mid!r}, x={self.x:.2f}, y={self.y:.2f}, r1={r1}, r2={r2})  # {meta}"


# %% ../notebooks/01_markings.ipynb 12
class Blotches:
    """Container for Blotch objects with idempotent plotting.

    The class creates a fresh PatchCollection on each call to `plot()` and
    removes any previously-added collection to avoid Matplotlib errors when
    reusing the same Blotches instance across axes/figures.
    """

    def __init__(self, df, with_center=False, color="red"):
        self.df = df
        self.with_center = with_center
        self.color = color
        # Keep the Blotch objects for per-item operations
        self.collection = [Blotch(blotch, with_center=self.with_center) for _, blotch in self.df.iterrows()]
        # Last PatchCollection artist added to an axes
        self._last_collection = None
        # Try to populate area columns when possible
        try:
            self.df["area"] = [item.area for item in self.collection]
            self.df["area_m2"] = self.df["map_scale"] ** 2 * self.df["area"]
        except Exception:
            pass

    @property
    def tile_id(self):
        try:
            return self.df.tile_id.iloc[0]
        except Exception:
            return getattr(self, "_tile_id", None)

    def plot(self, ax=None, color=None, linewidth=2.0, **kwargs):
        """Plot all blotches as a PatchCollection on `ax`.

        This method creates fresh Ellipse patches from the backing data rather
        than re-using previously-added artists, and removes any prior
        PatchCollection added by this object so plotting is idempotent.
        """
        if ax is None:
            _, ax = plt.subplots()
        ax = show_subframe(self.tile_id, ax=ax)

        # Remove old collection if present
        if getattr(self, "_last_collection", None) is not None:
            try:
                self._last_collection.remove()
            except Exception:
                pass
            finally:
                self._last_collection = None

        patches = []
        for b in self.collection:
            # build fresh Ellipse patch from the stored data
            center = (float(b.data.x), float(b.data.y))
            width = float(b.data.radius_1) * 2
            height = float(b.data.radius_2) * 2
            angle = float(b.data.angle)
            p = mpatches.Ellipse(xy=center, width=width, height=height, angle=angle, alpha=0.65, linewidth=linewidth, fill=False)
            if color is not None:
                p.set_edgecolor(color)
            patches.append(p)

        # Build a PatchCollection from the fresh patches and add it to the axes
        pc = PatchCollection(patches, match_original=True)
        ax.add_collection(pc)
        set_subframe_size(ax)

        # store for later removal
        self._last_collection = pc
        return pc

    def __repr__(self):
        tid = getattr(self, "tile_id", None)
        n = len(self.collection)
        sample = [getattr(b.data, "marking_id", None) for b in self.collection[:3]]
        return f"Blotches(tile_id={tid!r}, n={n}, sample={sample})"


# %% ../notebooks/01_markings.ipynb 13
class TileBlotches(Blotches):
    def __init__(self, tile_id, with_center=False, color="green"):
        """Container for all blotches of a tile.

        Parameters
        ----------
        tile_id : str
            planetfour tile_id
        """
        df = io.get_blotches_for_tile(tile_id)
        super().__init__(df, with_center=with_center, color=color)


# %% ../notebooks/01_markings.ipynb 16
def rotate_vector(v, angle):
    """Rotate vector by angle given in degrees.

    Parameters
    ----------
    v : np.array
        Vector to be rotated
    angle : float
        Angle in degrees
    """
    rangle = radians(angle)
    rotmat = np.array([[cos(rangle), -sin(rangle)], [sin(rangle), cos(rangle)]])
    # Ensure input is a 1-D numpy array of length 2
    v_arr = np.asarray(v, dtype=float).ravel()
    if v_arr.size != 2:
        raise ValueError(f"rotate_vector expects a length-2 vector, got shape {v_arr.shape}")
    return rotmat.dot(v_arr)

# %% ../notebooks/01_markings.ipynb 17
class Fan(lines.Line2D):
    to_average = "x y image_x image_y angle spread distance".split()

    @classmethod
    def from_tile_id(cls, tile_id, n=0, **kwargs):
        df = io.get_fan_catalog()
        data = df[df.tile_id == tile_id].iloc[n]
        return cls(data, **kwargs)

    @classmethod
    def from_marking_id(cls, marking_id, version=None, **kwargs):
        """Factory to create a Fan from a stable marking_id.

        `version` is passed to the catalog accessor when possible.
        """
        if version is None:
            df = io.get_fan_catalog()
        else:
            try:
                df = io.get_fan_catalog(version)
            except TypeError:
                df = io.get_fan_catalog()
        sel = df[df.marking_id == marking_id]
        if sel.empty:
            raise KeyError(f"marking_id {marking_id!r} not found in fan catalog")
        data = sel.squeeze()
        return cls(data, **kwargs)

    def __init__(
        self,
        data,  # object with fan data attributes: x, y, angle, spread, distance
        scope="planet4",  # "planet4" or "hirise",
        with_center=False,  # if True, plot the center of the fan,
        **kwargs,
    ):
        """
        Fan management class for P4.

        Attributes
        ----------
        to_average : list
            List of columns to average after clustering
        data : object with fan data attributes
            as provided by `data`.
        base : tuple
            base coordinates `x` and `y`.
        inside_half : float
            `data` divided by 2.0.
        armlength : float
            length of the fan arms.
        v1 : float[2]
            vector of first arm of fan.
        v2 : float[2]
        coords : float[3, 2]
            Set of coords to draw for MPL.Line2D object: arm1->base->arm2
        circle_base
        center
        radius
        midpoint
        base_to_midpoint_vec
        """
        self.data = data
        self.scope = scope if scope is not None else "planet4"
        self.with_center = with_center
        if scope not in ["hirise", "planet4"]:
            raise TypeError("Unknown scope: {}".format(scope))
        # first coordinate is the base of fan
        actual_x = "x" if scope == "planet4" else "image_x"
        actual_y = "y" if scope == "planet4" else "image_y"
        try:
            self.base = np.asarray(self.data.loc[[actual_x, actual_y]].values.astype("float")).ravel()
        except KeyError:
            print("No x and y in the data:\n{}".format(data))
            raise KeyError
        # default n_members value (property)
        self._n_members = 1
        # angles
        self.inside_half = self.data.spread / 2.0
        alpha = self.data.angle - self.inside_half
        beta = self.data.angle + self.inside_half
        # length of arms
        # first arm
        self.v1 = np.asarray(rotate_vector([self.armlength, 0], alpha), dtype=float).ravel()
        # second arm
        self.v2 = np.asarray(rotate_vector([self.armlength, 0], beta), dtype=float).ravel()
        # vector matrix, stows the 1D vectors row-wise
        self.coords = np.vstack((self.base + self.v1, self.base, self.base + self.v2))
        # Validate coords shape
        if self.coords.shape != (3, 2):
            raise ValueError(f"Fan.coords expected shape (3,2), got {self.coords.shape}. base={self.base}, v1={self.v1}, v2={self.v2}")
        # init fan line, first column are the x-components of the row-vectors
        lines.Line2D.__init__(
            self,
            self.coords[:, 0],
            self.coords[:, 1],
            alpha=0.65,
            **kwargs,
        )

    def is_equal(self, other):
        if (
            self.data.x == other.data.x
            and self.data.y == other.data.y
            and self.data.image_x == other.data.image_x
            and self.data.image_y == other.data.image_y
            and self.data.angle == other.data.angle
            and self.data.spread == other.data.spread
            and self.data.distance == other.data.distance
        ):
            return True
        else:
            return False

    @property
    def tile_id(self):
        return self.data.tile_id

    @property
    def n_members(self):
        return self._n_members

    @n_members.setter
    def n_members(self, value):
        self._n_members = value

    @property
    def armlength(self):
        """Length of the fan arms.
        
        The trick is to realize: $d = h + r$, where _d_ is the measured distance,
        _h_ is the height of the triangle formed by the two arms, and _r_ is the radius
        of the semi-circle at the end of the fan. Using trigonometry, we can kick out r.
        """
        half = radians(self.inside_half)
        return self.data.distance / (cos(half) + sin(half))

    @property
    def area(self):
        tr_h = np.sqrt(self.armlength**2 - self.radius**2)
        tr_area = tr_h * self.radius
        half_circ_area = 0.5 * pi * self.radius**2
        return tr_area + half_circ_area

    @property
    def circle_base(self):
        "float[2] : Vector between end of first arm and second arm of fan."
        return self.v1 - self.v2

    @property
    def semi_circle_center(self):
        """float[2] : vector from base to mid-point between end of arms.

        This is used for the drawing of the semi-circle at the end of the
        two fan arms.
        """
        return self.base + self.v2 + 0.5 * self.circle_base

    @property
    def radius(self):
        "float : for the semi-circle wedge drawing at the end of fan."
        return 0.5 * LA.norm(self.circle_base)

    def add_semicircle(self, ax, color="b"):
        "Draw a semi-circle at end of fan arms using MPL.Wedge."
        # reverse order of arguments for arctan2 input requirements
        theta1 = degrees(arctan2(*self.circle_base[::-1]))
        theta2 = theta1 + 180
        wedge = mpatches.Wedge(
            self.semi_circle_center,
            self.radius,
            theta1,
            theta2,
            width=0.01 * self.radius,
            color=color,
            alpha=0.65,
        )
        # Remove previously drawn semicircle (if any) so repeated plotting is idempotent
        if hasattr(self, "_last_wedge") and self._last_wedge is not None:
            try:
                self._last_wedge.remove()
            except Exception:
                pass
        ax.add_patch(wedge)
        self._last_wedge = wedge

    def add_mean_wind_pointer(self, ax, color="b", ls="-"):
        "Draw a thicker mean wind direction pointer for better visibility in plots."
        endpoint = rotate_vector([3 * self.armlength, 0], self.data.angle)
        coords = np.vstack((self.base, self.base + endpoint))
        self.wind_pointer_end = coords[1]
        pointer = lines.Line2D(
            coords[:, 0], coords[:, 1], alpha=0.65, linewidth=1, linestyle=ls
        )
        pointer.set_color(color)
        ax.add_line(pointer)

    def plot(self, color='green', ax=None):
        if ax is None:
            _, ax = plt.subplots()
        ax = show_subframe(self.tile_id, ax=ax)
        # Remove previous line and semicircle if present to keep plotting idempotent
        if hasattr(self, "_last_line") and self._last_line is not None:
            try:
                self._last_line.remove()
            except Exception:
                pass
        if hasattr(self, "_last_wedge") and self._last_wedge is not None:
            try:
                self._last_wedge.remove()
            except Exception:
                pass
        # Create a fresh Line2D for plotting so the same Fan instance can be plotted multiple times
        line = lines.Line2D(self.coords[:, 0], self.coords[:, 1], alpha=0.65, color=color if color is not None else 'white')
        ax.add_line(line)
        self.add_semicircle(ax, color=color)
        if self.with_center:
            # If we've drawn a center marker before, try to remove it first
            if hasattr(self, "_last_center") and self._last_center is not None:
                try:
                    self._last_center.remove()
                except Exception:
                    pass
            # plot_center returns a scatter PathCollection which we can store
            self._last_center = self.plot_center(ax, color=color)
        set_subframe_size(ax)
        # remember last drawn line in case the caller wants to remove it later
        self._last_line = line
        return line

    @property
    def center(self):
        """Calculate vector to half total length.

        As total length, I define the armlength + the radius of the semi-circle
        at the end.
        """
        mid_point_vec = rotate_vector([0.5 * (self.armlength + self.radius), 0], self.data.angle)
        return self.base + mid_point_vec

    def plot_center(self, ax, color="b"):
        # Return the scatter object so callers can track/remove it
        return ax.scatter(self.center[0], self.center[1], color=color, s=20, marker=".")

    @property
    def base_to_center_vec(self):
        coords = np.vstack((self.base, self.center))
        return coords

    def add_midpoint_pointer(self, ax, color="b", ls="-"):
        coords = self.base_to_center_vec
        pointer = lines.Line2D(coords[:, 0], coords[:, 1], alpha=0.65, linewidth=3, linestyle=ls)
        pointer.set_color(color)
        ax.add_line(pointer)

    def __str__(self):
        out = "markings.Fan object. Input data:\n"

        out += "base: {0}\narmlength: {1}\narm1: {2}\narm2: {3}".format(self.base, self.armlength, self.base + self.v1, self.base + self.v2)
        return out

    def __repr__(self):
        # Prefer factory-style repr when marking_id is available, include metadata comment
        mid = self.data.marking_id
        tile = self.data.tile_id
        area = float(self.area)
        meta = f"tile_id={tile!r}, area={area!r}"
        if mid is not None:
            return f"Fan.from_marking_id({mid!r})  # {meta}"
        # fallback concise summary with metadata comment
        try:
            bx, by = float(self.base[0]), float(self.base[1])
        except Exception:
            bx, by = (None, None)
        angle = getattr(self.data, 'angle', None)
        spread = getattr(self.data, 'spread', None)
        return f"Fan(marking_id={mid!r}, base=({bx:.2f},{by:.2f}), angle={angle}, spread={spread})  # {meta}"

    def store(self, fpath=None):
        out = self.data
        for i, arm in enumerate([self.v1, self.v2]):
            out["arm{}_x".format(i + 1)] = (self.base + arm)[0]
            out["arm{}_y".format(i + 1)] = (self.base + arm)[1]
        if "image_id" not in out.index:
            # out['image_id'] = self.image_id
            raise AttributeError("Storage of image_id failed.")
        if fpath is not None:
            out.to_hdf(str(fpath.with_suffix(".hdf")), "df")
        out["n_members"] = self.n_members
        return out

    def to_shapely(self):
        """Create a shapely half circle rotated by the fan's angle.

        Notes
        =====
        `Motivated by: <https://stackoverflow.com/a/30762727/680232>`_
        """
        # Define the arc (presumably ezdxf uses a similar convention)
        centerx, centery = self.semi_circle_center

        # make a semi-circle first that points to the x-axis, rotate later.
        start_angle = 270  # In degrees

        # number of elements for the semi-circle
        numsegments = 100

        # The coordinates of the arc
        theta = np.radians(np.linspace(start_angle, start_angle + 180, numsegments))
        x = centerx + self.radius * np.cos(theta)
        y = centery + self.radius * np.sin(theta)

        arc = geom.LineString(np.column_stack([x, y]))

        rotated = affinity.rotate(arc, self.data.angle, origin=tuple(self.semi_circle_center))

        # Extract rotated arc coordinates as an (N,2) array
        rot_coords = np.array(list(rotated.coords))
        df = pd.DataFrame(np.vstack([self.coords[::-1][:2], rot_coords]))
        return geom.Polygon(df.round(2).drop_duplicates().values)


# %% ../notebooks/01_markings.ipynb 22
class Fans:
    """Container for Fan objects backed by a LineCollection for plotting.

    This class keeps a list of `Fan` instances in `self.collection` and a
    matching list of 2D arrays in `self.segments` suitable for
    `matplotlib.collections.LineCollection`.

    The `plot` method is idempotent: it removes any previously-added
    LineCollection artist before adding a fresh one, so calling `.plot()`
    repeatedly or from different axes won't raise Matplotlib errors.
    """

    def __init__(self, df, scope="planet4", with_center=False, color="green", **kwargs):
        self.df = df
        self.scope = scope
        self.with_center = with_center
        self.color = color
        # Build Fan objects (these are Line2D-derived but we won't hand them
        # directly to LineCollection). Keep them for per-fan operations.
        self.collection = [Fan(row, with_center=self.with_center) for _, row in self.df.iterrows()]
        # Extract numeric segments (N,2) arrays for LineCollection
        self.segments = [np.asarray(f.coords, dtype=float) for f in self.collection]
        # Storage for last LineCollection artist so we can remove it on re-plot
        self._last_collection = None
        # Try to populate area columns when possible
        try:
            self.df["area"] = [item.area for item in self.collection]
            self.df["area_m2"] = self.df["map_scale"] ** 2 * self.df["area"]
        except Exception:
            # Non-fatal: leave dataframe unchanged if area computation fails
            pass

    @property
    def tile_id(self):
        # Return the tile_id associated with this Fans collection, if available
        try:
            return self.df.tile_id.iloc[0]
        except Exception:
            return getattr(self, "_tile_id", None)

    def plot(self, ax=None, color=None, linewidth=1.0, **kwargs):
        """Plot all fans as a LineCollection on `ax`.

        Parameters
        ----------
        ax : matplotlib.axes.Axes or None
            Axis to plot on. If None, a new figure/axis is created.
        color : matplotlib color or None
            Edge color for the lines; falls back to the collection's color.
        linewidth : float
            Line width for the LineCollection.
        """
        if ax is None:
            _, ax = plt.subplots()
        ax = show_subframe(self.tile_id, ax=ax)
        # Remove any previous LineCollection artist to avoid re-adding the same
        # artist to multiple axes (which raises a RuntimeError).
        if getattr(self, "_last_collection", None) is not None:
            try:
                self._last_collection.remove()
            except Exception:
                # ignore removal errors; we'll create a fresh collection below
                pass
            finally:
                self._last_collection = None
        # Create a new LineCollection from the numeric segments
        cols = color if color is not None else self.color
        lc = LineCollection(self.segments, colors=cols, linewidths=linewidth, **kwargs)
        ax.add_collection(lc)
        set_subframe_size(ax)
        self._last_collection = lc
        return lc

    def __repr__(self):
        tid = getattr(self, "tile_id", None)
        n = len(self.collection)
        sample = [getattr(f.data, "marking_id", None) for f in self.collection[:3]]
        return f"Fans(tile_id={tid!r}, n={n}, sample={sample})"


# %% ../notebooks/01_markings.ipynb 26
class TileFans(Fans):
    def __init__(self, tile_id, scope="planet4", with_center=False, color="green", **kwargs):
        """Container for all fans of a tile.

        Convenience subclass that builds a `Fans` collection from a tile id.
        """
        df = io.get_fans_for_tile(tile_id)
        super().__init__(df, scope=scope, with_center=with_center, color=color, **kwargs)

